/* tslint:disable */
/* eslint-disable */
/**
 * CrowdStrike API Specification
 * Use this API specification as a reference for the API endpoints you can use to interact with your Falcon environment. These endpoints support authentication via OAuth2 and interact with detections and network containment. For detailed usage guides and examples, see our [documentation inside the Falcon console](https://falcon.crowdstrike.com/support/documentation).     To use the APIs described below, combine the base URL with the path shown for each API endpoint. For commercial cloud customers, your base URL is `https://api.crowdstrike.com`.    Each API endpoint requires authorization via an OAuth2 token. Your first API request should retrieve an OAuth2 token using the `oauth2/token` endpoint, such as `https://api.crowdstrike.com/oauth2/token`. For subsequent requests, include the OAuth2 token in an HTTP authorization header. Tokens expire after 30 minutes, after which you should make a new token request to continue making API requests.
 *
 * The version of the OpenAPI document: rolling
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from "../runtime";
/**
 *
 * @export
 * @interface DetectsAlert
 */
export interface DetectsAlert {
    /**
     * Device or sensor ID for which the Alert was generated
     * @type {string}
     * @memberof DetectsAlert
     */
    agentId?: string;
    /**
     * Common linkage between multiple Alerts that belong so the same detection bouquet
     * @type {string}
     * @memberof DetectsAlert
     */
    aggregateId?: string;
    /**
     * Name of the person this Alert is assigned to
     * @type {string}
     * @memberof DetectsAlert
     */
    assignedToName?: string;
    /**
     * UserID to which this Alert is assigned to
     * @type {string}
     * @memberof DetectsAlert
     */
    assignedToUid?: string;
    /**
     * UUID to which this Alert is assigned to
     * @type {string}
     * @memberof DetectsAlert
     */
    assignedToUuid?: string;
    /**
     * Unique ID of CrowdStrike customers
     * @type {string}
     * @memberof DetectsAlert
     */
    cid?: string;
    /**
     * An opaque internal identifier that can uniquely identify an Alert
     * @type {string}
     * @memberof DetectsAlert
     */
    compositeId?: string;
    /**
     * Confidence is a 1-100 integer value denoting the confidence that, when this Alert fires, it is indicative of malicious activity
     * @type {number}
     * @memberof DetectsAlert
     */
    confidence?: number;
    /**
     * internal only
     * @type {{ [key: string]: Array<string>; }}
     * @memberof DetectsAlert
     */
    crawlEdgeIds?: { [key: string]: Array<string> };
    /**
     * internal only
     * @type {{ [key: string]: Array<string>; }}
     * @memberof DetectsAlert
     */
    crawlVertexIds?: { [key: string]: Array<string> };
    /**
     * indicates when ThreatGraph was crawled to gather info for this alert creation/update
     * @type {Date}
     * @memberof DetectsAlert
     */
    crawledTimestamp?: Date;
    /**
     * indicates when the Alert was first written to backend store
     * @type {Date}
     * @memberof DetectsAlert
     */
    createdTimestamp?: Date;
    /**
     * Data Domains represents domains to which this alert belongs to
     * @type {Array<string>}
     * @memberof DetectsAlert
     */
    dataDomains?: Array<string>;
    /**
     * Short, customer-visible summary of the detected activity
     * @type {string}
     * @memberof DetectsAlert
     */
    description?: string;
    /**
     * Customer visible name for the Alert's pattern
     * @type {string}
     * @memberof DetectsAlert
     */
    displayName?: string;
    /**
     * Boolean to know if we sent email regarding this Alert
     * @type {boolean}
     * @memberof DetectsAlert
     */
    emailSent?: boolean;
    /**
     * internal only
     * @type {string}
     * @memberof DetectsAlert
     */
    esDocId?: string;
    /**
     * internal only
     * @type {number}
     * @memberof DetectsAlert
     */
    esDocVersion?: number;
    /**
     * internal only
     * @type {string}
     * @memberof DetectsAlert
     */
    esRoutingId?: string;
    /**
     * Boolean indicating if this Alert is internal or external
     * @type {boolean}
     * @memberof DetectsAlert
     */
    external?: boolean;
    /**
     * Vertex key which triggers the formation of the Alert
     * @type {string}
     * @memberof DetectsAlert
     */
    id?: string;
    /**
     * Pattern Name coming either from Taxonomy or directly from the ingested Alert
     * @type {string}
     * @memberof DetectsAlert
     */
    name?: string;
    /**
     * End goal that an attack adversary intends to achieve according to MITRE
     * @type {string}
     * @memberof DetectsAlert
     */
    objective?: string;
    /**
     * Taxonomy patternID for this Alert
     * @type {number}
     * @memberof DetectsAlert
     */
    patternId?: number;
    /**
     * Platform that this Alert was triggered on e.g. Android, Windows, etc..
     * @type {string}
     * @memberof DetectsAlert
     */
    platform?: string;
    /**
     *
     * @type {string}
     * @memberof DetectsAlert
     */
    polyId?: string;
    /**
     * Product specifies the SKU that this Alert belongs to e.g. mobile, idp, epp
     * @type {string}
     * @memberof DetectsAlert
     */
    product?: string;
    /**
     * Scenario was used pre-Handrails to display additional killchain context for UI alerts. With handrails, this field is mostly  obsolete in favor of tactic/technique. Still, it can be useful for determining specific pattern types that are not straightforward to distinguish from other fields alone
     * @type {string}
     * @memberof DetectsAlert
     */
    scenario?: string;
    /**
     * Severity is also a 1-100 integer value, but unlike confidence severity impacts how a Alert is displayed in the UI
     * @type {number}
     * @memberof DetectsAlert
     */
    severity?: number;
    /**
     * Boolean indicating if this Alert will be shown in the UI or if it's hidden'
     * @type {boolean}
     * @memberof DetectsAlert
     */
    showInUi?: boolean;
    /**
     * Source Products are products that produced events which contributed to this alert
     * @type {Array<string>}
     * @memberof DetectsAlert
     */
    sourceProducts?: Array<string>;
    /**
     * Source Vendors are vendors that produced events which contributed to this alert
     * @type {Array<string>}
     * @memberof DetectsAlert
     */
    sourceVendors?: Array<string>;
    /**
     * Could be one of the following - New, closed, in_progress, reopened
     * @type {string}
     * @memberof DetectsAlert
     */
    status?: string;
    /**
     * Tactic and Technique are references to MITRE ATT&CK, which is a public framework for tracking and modeling adversary tools techniques and procedures
     * @type {string}
     * @memberof DetectsAlert
     */
    tactic?: string;
    /**
     * Unique ID for the tactic seen in the Alert
     * @type {string}
     * @memberof DetectsAlert
     */
    tacticId?: string;
    /**
     * Tags are string values associated with the alert that can be added or removed through the API
     * @type {Array<string>}
     * @memberof DetectsAlert
     */
    tags?: Array<string>;
    /**
     * Tactic and Technique are references to MITRE ATT&CK, which is a public framework for tracking and modeling adversary tools techniques and procedures
     * @type {string}
     * @memberof DetectsAlert
     */
    technique?: string;
    /**
     * Unique ID for the technique seen in the Alert
     * @type {string}
     * @memberof DetectsAlert
     */
    techniqueId?: string;
    /**
     * stored value coming in directly from the ingested event or set by cloud in the absence of it
     * @type {Date}
     * @memberof DetectsAlert
     */
    timestamp?: Date;
    /**
     * Type of definition Detections Extensibility use. Keyed-off of Pattern of the incoming events/Alerts
     * @type {string}
     * @memberof DetectsAlert
     */
    type: string;
    /**
     * indicates when the Alert was last modified
     * @type {Date}
     * @memberof DetectsAlert
     */
    updatedTimestamp?: Date;
}

/**
 * Check if a given object implements the DetectsAlert interface.
 */
export function instanceOfDetectsAlert(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "type" in value;

    return isInstance;
}

export function DetectsAlertFromJSON(json: any): DetectsAlert {
    return DetectsAlertFromJSONTyped(json, false);
}

export function DetectsAlertFromJSONTyped(json: any, ignoreDiscriminator: boolean): DetectsAlert {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        agentId: !exists(json, "agent_id") ? undefined : json["agent_id"],
        aggregateId: !exists(json, "aggregate_id") ? undefined : json["aggregate_id"],
        assignedToName: !exists(json, "assigned_to_name") ? undefined : json["assigned_to_name"],
        assignedToUid: !exists(json, "assigned_to_uid") ? undefined : json["assigned_to_uid"],
        assignedToUuid: !exists(json, "assigned_to_uuid") ? undefined : json["assigned_to_uuid"],
        cid: !exists(json, "cid") ? undefined : json["cid"],
        compositeId: !exists(json, "composite_id") ? undefined : json["composite_id"],
        confidence: !exists(json, "confidence") ? undefined : json["confidence"],
        crawlEdgeIds: !exists(json, "crawl_edge_ids") ? undefined : json["crawl_edge_ids"],
        crawlVertexIds: !exists(json, "crawl_vertex_ids") ? undefined : json["crawl_vertex_ids"],
        crawledTimestamp: !exists(json, "crawled_timestamp") ? undefined : new Date(json["crawled_timestamp"]),
        createdTimestamp: !exists(json, "created_timestamp") ? undefined : new Date(json["created_timestamp"]),
        dataDomains: !exists(json, "data_domains") ? undefined : json["data_domains"],
        description: !exists(json, "description") ? undefined : json["description"],
        displayName: !exists(json, "display_name") ? undefined : json["display_name"],
        emailSent: !exists(json, "email_sent") ? undefined : json["email_sent"],
        esDocId: !exists(json, "es_doc_id") ? undefined : json["es_doc_id"],
        esDocVersion: !exists(json, "es_doc_version") ? undefined : json["es_doc_version"],
        esRoutingId: !exists(json, "es_routing_id") ? undefined : json["es_routing_id"],
        external: !exists(json, "external") ? undefined : json["external"],
        id: !exists(json, "id") ? undefined : json["id"],
        name: !exists(json, "name") ? undefined : json["name"],
        objective: !exists(json, "objective") ? undefined : json["objective"],
        patternId: !exists(json, "pattern_id") ? undefined : json["pattern_id"],
        platform: !exists(json, "platform") ? undefined : json["platform"],
        polyId: !exists(json, "poly_id") ? undefined : json["poly_id"],
        product: !exists(json, "product") ? undefined : json["product"],
        scenario: !exists(json, "scenario") ? undefined : json["scenario"],
        severity: !exists(json, "severity") ? undefined : json["severity"],
        showInUi: !exists(json, "show_in_ui") ? undefined : json["show_in_ui"],
        sourceProducts: !exists(json, "source_products") ? undefined : json["source_products"],
        sourceVendors: !exists(json, "source_vendors") ? undefined : json["source_vendors"],
        status: !exists(json, "status") ? undefined : json["status"],
        tactic: !exists(json, "tactic") ? undefined : json["tactic"],
        tacticId: !exists(json, "tactic_id") ? undefined : json["tactic_id"],
        tags: !exists(json, "tags") ? undefined : json["tags"],
        technique: !exists(json, "technique") ? undefined : json["technique"],
        techniqueId: !exists(json, "technique_id") ? undefined : json["technique_id"],
        timestamp: !exists(json, "timestamp") ? undefined : new Date(json["timestamp"]),
        type: json["type"],
        updatedTimestamp: !exists(json, "updated_timestamp") ? undefined : new Date(json["updated_timestamp"]),
    };
}

export function DetectsAlertToJSON(value?: DetectsAlert | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        agent_id: value.agentId,
        aggregate_id: value.aggregateId,
        assigned_to_name: value.assignedToName,
        assigned_to_uid: value.assignedToUid,
        assigned_to_uuid: value.assignedToUuid,
        cid: value.cid,
        composite_id: value.compositeId,
        confidence: value.confidence,
        crawl_edge_ids: value.crawlEdgeIds,
        crawl_vertex_ids: value.crawlVertexIds,
        crawled_timestamp: value.crawledTimestamp === undefined ? undefined : value.crawledTimestamp.toISOString(),
        created_timestamp: value.createdTimestamp === undefined ? undefined : value.createdTimestamp.toISOString(),
        data_domains: value.dataDomains,
        description: value.description,
        display_name: value.displayName,
        email_sent: value.emailSent,
        es_doc_id: value.esDocId,
        es_doc_version: value.esDocVersion,
        es_routing_id: value.esRoutingId,
        external: value.external,
        id: value.id,
        name: value.name,
        objective: value.objective,
        pattern_id: value.patternId,
        platform: value.platform,
        poly_id: value.polyId,
        product: value.product,
        scenario: value.scenario,
        severity: value.severity,
        show_in_ui: value.showInUi,
        source_products: value.sourceProducts,
        source_vendors: value.sourceVendors,
        status: value.status,
        tactic: value.tactic,
        tactic_id: value.tacticId,
        tags: value.tags,
        technique: value.technique,
        technique_id: value.techniqueId,
        timestamp: value.timestamp === undefined ? undefined : value.timestamp.toISOString(),
        type: value.type,
        updated_timestamp: value.updatedTimestamp === undefined ? undefined : value.updatedTimestamp.toISOString(),
    };
}
