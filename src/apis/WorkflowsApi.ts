/* tslint:disable */
/* eslint-disable */
/**
 * CrowdStrike API Specification
 * Use this API specification as a reference for the API endpoints you can use to interact with your Falcon environment. These endpoints support authentication via OAuth2 and interact with detections and network containment. For detailed usage guides and examples, see our [documentation inside the Falcon console](https://falcon.crowdstrike.com/support/documentation).     To use the APIs described below, combine the base URL with the path shown for each API endpoint. For commercial cloud customers, your base URL is `https://api.crowdstrike.com`.    Each API endpoint requires authorization via an OAuth2 token. Your first API request should retrieve an OAuth2 token using the `oauth2/token` endpoint, such as `https://api.crowdstrike.com/oauth2/token`. For subsequent requests, include the OAuth2 token in an HTTP authorization header. Tokens expire after 30 minutes, after which you should make a new token request to continue making API requests.
 *
 * The version of the OpenAPI document: rolling
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
    ActivitiesActivityExternalResponse,
    ApiExecutionResultsResponse,
    ApiMFAResourceIDsResponse,
    ApiResourceIDsResponse,
    ClientActionRequest,
    ClientSystemDefinitionCreateResponse,
    ClientSystemDefinitionDeProvisionRequest,
    ClientSystemDefinitionPromoteRequest,
    ClientSystemDefinitionProvisionRequest,
    DefinitionsDefinitionEntitiesResponse,
    DefinitionsDefinitionExternalResponse,
    DefinitionsDefinitionImportResponse,
    ModelUserInputReadResponse,
    ModelUserInputUpdateRequest,
    ModelsDefinitionUpdateRequestV2,
    ModelsMockExecutionCreateRequestV1,
    MsaReplyMetaOnly,
    TriggersTriggerExternalResponse,
} from "../models/index";
import {
    ActivitiesActivityExternalResponseFromJSON,
    ActivitiesActivityExternalResponseToJSON,
    ApiExecutionResultsResponseFromJSON,
    ApiExecutionResultsResponseToJSON,
    ApiMFAResourceIDsResponseFromJSON,
    ApiMFAResourceIDsResponseToJSON,
    ApiResourceIDsResponseFromJSON,
    ApiResourceIDsResponseToJSON,
    ClientActionRequestFromJSON,
    ClientActionRequestToJSON,
    ClientSystemDefinitionCreateResponseFromJSON,
    ClientSystemDefinitionCreateResponseToJSON,
    ClientSystemDefinitionDeProvisionRequestFromJSON,
    ClientSystemDefinitionDeProvisionRequestToJSON,
    ClientSystemDefinitionPromoteRequestFromJSON,
    ClientSystemDefinitionPromoteRequestToJSON,
    ClientSystemDefinitionProvisionRequestFromJSON,
    ClientSystemDefinitionProvisionRequestToJSON,
    DefinitionsDefinitionEntitiesResponseFromJSON,
    DefinitionsDefinitionEntitiesResponseToJSON,
    DefinitionsDefinitionExternalResponseFromJSON,
    DefinitionsDefinitionExternalResponseToJSON,
    DefinitionsDefinitionImportResponseFromJSON,
    DefinitionsDefinitionImportResponseToJSON,
    ModelUserInputReadResponseFromJSON,
    ModelUserInputReadResponseToJSON,
    ModelUserInputUpdateRequestFromJSON,
    ModelUserInputUpdateRequestToJSON,
    ModelsDefinitionUpdateRequestV2FromJSON,
    ModelsDefinitionUpdateRequestV2ToJSON,
    ModelsMockExecutionCreateRequestV1FromJSON,
    ModelsMockExecutionCreateRequestV1ToJSON,
    MsaReplyMetaOnlyFromJSON,
    MsaReplyMetaOnlyToJSON,
    TriggersTriggerExternalResponseFromJSON,
    TriggersTriggerExternalResponseToJSON,
} from "../models/index";

export interface WorkflowsApiDeprovisionRequest {
    body: ClientSystemDefinitionDeProvisionRequest;
}

export interface WorkflowsApiExecuteRequest {
    body: object;
    executionCid?: Array<string>;
    definitionId?: Array<string>;
    name?: string;
    key?: string;
    depth?: number;
    sourceEventUrl?: string;
}

export interface WorkflowsApiExecutionActionRequest {
    actionName: ExecutionActionActionNameEnum;
    body: ClientActionRequest;
}

export interface WorkflowsApiExecutionResultsRequest {
    ids: Array<string>;
}

export interface WorkflowsApiPromoteRequest {
    body: ClientSystemDefinitionPromoteRequest;
}

export interface WorkflowsApiProvisionRequest {
    body: ClientSystemDefinitionProvisionRequest;
}

export interface WorkflowsApiWorkflowActivitiesCombinedRequest {
    filter?: string;
    offset?: string;
    limit?: number;
    sort?: string;
}

export interface WorkflowsApiWorkflowDefinitionsCombinedRequest {
    filter?: string;
    offset?: string;
    limit?: number;
    sort?: string;
}

export interface WorkflowsApiWorkflowDefinitionsExportRequest {
    id: string;
    sanitize?: boolean;
}

export interface WorkflowsApiWorkflowDefinitionsImportRequest {
    dataFile: Blob;
    name?: string;
    validateOnly?: boolean;
}

export interface WorkflowsApiWorkflowDefinitionsUpdateRequest {
    body: ModelsDefinitionUpdateRequestV2;
    validateOnly?: boolean;
}

export interface WorkflowsApiWorkflowExecuteInternalRequest {
    body: object;
    executionCid?: Array<string>;
    definitionId?: Array<string>;
    name?: string;
    key?: string;
    depth?: number;
    batchSize?: number;
    sourceEventUrl?: string;
}

export interface WorkflowsApiWorkflowExecutionsCombinedRequest {
    filter?: string;
    offset?: string;
    limit?: number;
    sort?: string;
}

export interface WorkflowsApiWorkflowGetHumanInputV1Request {
    ids: Array<string>;
}

export interface WorkflowsApiWorkflowMockExecuteRequest {
    body: ModelsMockExecutionCreateRequestV1;
    executionCid?: Array<string>;
    definitionId?: string;
    name?: string;
    key?: string;
    depth?: number;
    sourceEventUrl?: string;
    validateOnly?: boolean;
}

export interface WorkflowsApiWorkflowTriggersCombinedRequest {
    filter?: string;
}

export interface WorkflowsApiWorkflowUpdateHumanInputV1Request {
    id: string;
    body: ModelUserInputUpdateRequest;
}

/**
 *
 */
export class WorkflowsApi extends runtime.BaseAPI {
    /**
     * Deprovisions a system definition that was previously provisioned on the target CID
     */
    async deprovisionRaw(
        requestParameters: WorkflowsApiDeprovisionRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ClientSystemDefinitionCreateResponse>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling deprovision().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/workflows/system-definitions/deprovision/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: ClientSystemDefinitionDeProvisionRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ClientSystemDefinitionCreateResponseFromJSON(jsonValue));
    }

    /**
     * Deprovisions a system definition that was previously provisioned on the target CID
     */
    async deprovision(body: ClientSystemDefinitionDeProvisionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClientSystemDefinitionCreateResponse> {
        const response = await this.deprovisionRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Executes an on-demand Workflow, the body is JSON used to trigger the execution, the response the execution ID(s)
     */
    async executeRaw(requestParameters: WorkflowsApiExecuteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiResourceIDsResponse>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling execute().');
        }

        const queryParameters: any = {};

        if (requestParameters["executionCid"] != null) {
            queryParameters["execution_cid"] = requestParameters["executionCid"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters["definitionId"] != null) {
            queryParameters["definition_id"] = requestParameters["definitionId"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters["name"] != null) {
            queryParameters["name"] = requestParameters["name"];
        }

        if (requestParameters["key"] != null) {
            queryParameters["key"] = requestParameters["key"];
        }

        if (requestParameters["depth"] != null) {
            queryParameters["depth"] = requestParameters["depth"];
        }

        if (requestParameters["sourceEventUrl"] != null) {
            queryParameters["source_event_url"] = requestParameters["sourceEventUrl"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/workflows/entities/execute/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters["body"] as any,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiResourceIDsResponseFromJSON(jsonValue));
    }

    /**
     * Executes an on-demand Workflow, the body is JSON used to trigger the execution, the response the execution ID(s)
     */
    async execute(
        body: object,
        executionCid?: Array<string>,
        definitionId?: Array<string>,
        name?: string,
        key?: string,
        depth?: number,
        sourceEventUrl?: string,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ApiResourceIDsResponse> {
        const response = await this.executeRaw(
            { body: body, executionCid: executionCid, definitionId: definitionId, name: name, key: key, depth: depth, sourceEventUrl: sourceEventUrl },
            initOverrides,
        );
        return await response.value();
    }

    /**
     * Allows a user to resume/retry a failed workflow execution.
     */
    async executionActionRaw(
        requestParameters: WorkflowsApiExecutionActionRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DefinitionsDefinitionEntitiesResponse>> {
        if (requestParameters["actionName"] == null) {
            throw new runtime.RequiredError("actionName", 'Required parameter "actionName" was null or undefined when calling executionAction().');
        }

        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling executionAction().');
        }

        const queryParameters: any = {};

        if (requestParameters["actionName"] != null) {
            queryParameters["action_name"] = requestParameters["actionName"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/workflows/entities/execution-actions/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: ClientActionRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DefinitionsDefinitionEntitiesResponseFromJSON(jsonValue));
    }

    /**
     * Allows a user to resume/retry a failed workflow execution.
     */
    async executionAction(
        actionName: ExecutionActionActionNameEnum,
        body: ClientActionRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DefinitionsDefinitionEntitiesResponse> {
        const response = await this.executionActionRaw({ actionName: actionName, body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Get execution result of a given execution
     */
    async executionResultsRaw(
        requestParameters: WorkflowsApiExecutionResultsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiExecutionResultsResponse>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling executionResults().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/workflows/entities/execution-results/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiExecutionResultsResponseFromJSON(jsonValue));
    }

    /**
     * Get execution result of a given execution
     */
    async executionResults(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiExecutionResultsResponse> {
        const response = await this.executionResultsRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Promotes a version of a system definition for a customer. The customer must already have been provisioned. This allows the caller to apply an updated template version to a specific cid and expects all parameters to be supplied. If the template supports multi-instance the customer scope definition ID must be supplied to determine which customer workflow should be updated.
     */
    async promoteRaw(requestParameters: WorkflowsApiPromoteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ClientSystemDefinitionCreateResponse>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling promote().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/workflows/system-definitions/promote/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: ClientSystemDefinitionPromoteRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ClientSystemDefinitionCreateResponseFromJSON(jsonValue));
    }

    /**
     * Promotes a version of a system definition for a customer. The customer must already have been provisioned. This allows the caller to apply an updated template version to a specific cid and expects all parameters to be supplied. If the template supports multi-instance the customer scope definition ID must be supplied to determine which customer workflow should be updated.
     */
    async promote(body: ClientSystemDefinitionPromoteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClientSystemDefinitionCreateResponse> {
        const response = await this.promoteRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Provisions a system definition onto the target CID by using the template and provided parameters
     */
    async provisionRaw(
        requestParameters: WorkflowsApiProvisionRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ClientSystemDefinitionCreateResponse>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling provision().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/workflows/system-definitions/provision/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: ClientSystemDefinitionProvisionRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ClientSystemDefinitionCreateResponseFromJSON(jsonValue));
    }

    /**
     * Provisions a system definition onto the target CID by using the template and provided parameters
     */
    async provision(body: ClientSystemDefinitionProvisionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClientSystemDefinitionCreateResponse> {
        const response = await this.provisionRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Search for activities by name. Returns all supported activities if no filter specified
     */
    async workflowActivitiesCombinedRaw(
        requestParameters: WorkflowsApiWorkflowActivitiesCombinedRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ActivitiesActivityExternalResponse>> {
        const queryParameters: any = {};

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/workflows/combined/activities/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ActivitiesActivityExternalResponseFromJSON(jsonValue));
    }

    /**
     * Search for activities by name. Returns all supported activities if no filter specified
     */
    async workflowActivitiesCombined(
        filter?: string,
        offset?: string,
        limit?: number,
        sort?: string,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ActivitiesActivityExternalResponse> {
        const response = await this.workflowActivitiesCombinedRaw({ filter: filter, offset: offset, limit: limit, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Search workflow definitions based on the provided filter
     */
    async workflowDefinitionsCombinedRaw(
        requestParameters: WorkflowsApiWorkflowDefinitionsCombinedRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DefinitionsDefinitionExternalResponse>> {
        const queryParameters: any = {};

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/workflows/combined/definitions/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DefinitionsDefinitionExternalResponseFromJSON(jsonValue));
    }

    /**
     * Search workflow definitions based on the provided filter
     */
    async workflowDefinitionsCombined(
        filter?: string,
        offset?: string,
        limit?: number,
        sort?: string,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DefinitionsDefinitionExternalResponse> {
        const response = await this.workflowDefinitionsCombinedRaw({ filter: filter, offset: offset, limit: limit, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Exports a workflow definition for the given definition ID
     */
    async workflowDefinitionsExportRaw(
        requestParameters: WorkflowsApiWorkflowDefinitionsExportRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters["id"] == null) {
            throw new runtime.RequiredError("id", 'Required parameter "id" was null or undefined when calling workflowDefinitionsExport().');
        }

        const queryParameters: any = {};

        if (requestParameters["id"] != null) {
            queryParameters["id"] = requestParameters["id"];
        }

        if (requestParameters["sanitize"] != null) {
            queryParameters["sanitize"] = requestParameters["sanitize"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/workflows/entities/definitions/export/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Exports a workflow definition for the given definition ID
     */
    async workflowDefinitionsExport(id: string, sanitize?: boolean, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.workflowDefinitionsExportRaw({ id: id, sanitize: sanitize }, initOverrides);
        return await response.value();
    }

    /**
     * Imports a workflow definition based on the provided model
     */
    async workflowDefinitionsImportRaw(
        requestParameters: WorkflowsApiWorkflowDefinitionsImportRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DefinitionsDefinitionImportResponse>> {
        if (requestParameters["dataFile"] == null) {
            throw new runtime.RequiredError("dataFile", 'Required parameter "dataFile" was null or undefined when calling workflowDefinitionsImport().');
        }

        const queryParameters: any = {};

        if (requestParameters["name"] != null) {
            queryParameters["name"] = requestParameters["name"];
        }

        if (requestParameters["validateOnly"] != null) {
            queryParameters["validate_only"] = requestParameters["validateOnly"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const consumes: runtime.Consume[] = [{ contentType: "multipart/form-data" }];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters["dataFile"] != null) {
            formParams.append("data_file", requestParameters["dataFile"] as any);
        }

        const response = await this.request(
            {
                path: `/workflows/entities/definitions/import/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DefinitionsDefinitionImportResponseFromJSON(jsonValue));
    }

    /**
     * Imports a workflow definition based on the provided model
     */
    async workflowDefinitionsImport(dataFile: Blob, name?: string, validateOnly?: boolean, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DefinitionsDefinitionImportResponse> {
        const response = await this.workflowDefinitionsImportRaw({ dataFile: dataFile, name: name, validateOnly: validateOnly }, initOverrides);
        return await response.value();
    }

    /**
     * Updates a workflow definition based on the provided model
     */
    async workflowDefinitionsUpdateRaw(
        requestParameters: WorkflowsApiWorkflowDefinitionsUpdateRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiResourceIDsResponse>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling workflowDefinitionsUpdate().');
        }

        const queryParameters: any = {};

        if (requestParameters["validateOnly"] != null) {
            queryParameters["validate_only"] = requestParameters["validateOnly"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/workflows/entities/definitions/v1`,
                method: "PUT",
                headers: headerParameters,
                query: queryParameters,
                body: ModelsDefinitionUpdateRequestV2ToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiResourceIDsResponseFromJSON(jsonValue));
    }

    /**
     * Updates a workflow definition based on the provided model
     */
    async workflowDefinitionsUpdate(body: ModelsDefinitionUpdateRequestV2, validateOnly?: boolean, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiResourceIDsResponse> {
        const response = await this.workflowDefinitionsUpdateRaw({ body: body, validateOnly: validateOnly }, initOverrides);
        return await response.value();
    }

    /**
     * Executes an on-demand Workflow - internal workflows permitted, the body is JSON used to trigger the execution, the response the execution ID(s)
     */
    async workflowExecuteInternalRaw(
        requestParameters: WorkflowsApiWorkflowExecuteInternalRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiResourceIDsResponse>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling workflowExecuteInternal().');
        }

        const queryParameters: any = {};

        if (requestParameters["executionCid"] != null) {
            queryParameters["execution_cid"] = requestParameters["executionCid"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters["definitionId"] != null) {
            queryParameters["definition_id"] = requestParameters["definitionId"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters["name"] != null) {
            queryParameters["name"] = requestParameters["name"];
        }

        if (requestParameters["key"] != null) {
            queryParameters["key"] = requestParameters["key"];
        }

        if (requestParameters["depth"] != null) {
            queryParameters["depth"] = requestParameters["depth"];
        }

        if (requestParameters["batchSize"] != null) {
            queryParameters["batch_size"] = requestParameters["batchSize"];
        }

        if (requestParameters["sourceEventUrl"] != null) {
            queryParameters["source_event_url"] = requestParameters["sourceEventUrl"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/workflows/entities/execute/internal/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters["body"] as any,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiResourceIDsResponseFromJSON(jsonValue));
    }

    /**
     * Executes an on-demand Workflow - internal workflows permitted, the body is JSON used to trigger the execution, the response the execution ID(s)
     */
    async workflowExecuteInternal(
        body: object,
        executionCid?: Array<string>,
        definitionId?: Array<string>,
        name?: string,
        key?: string,
        depth?: number,
        batchSize?: number,
        sourceEventUrl?: string,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ApiResourceIDsResponse> {
        const response = await this.workflowExecuteInternalRaw(
            { body: body, executionCid: executionCid, definitionId: definitionId, name: name, key: key, depth: depth, batchSize: batchSize, sourceEventUrl: sourceEventUrl },
            initOverrides,
        );
        return await response.value();
    }

    /**
     * Search workflow executions based on the provided filter
     */
    async workflowExecutionsCombinedRaw(
        requestParameters: WorkflowsApiWorkflowExecutionsCombinedRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiExecutionResultsResponse>> {
        const queryParameters: any = {};

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/workflows/combined/executions/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiExecutionResultsResponseFromJSON(jsonValue));
    }

    /**
     * Search workflow executions based on the provided filter
     */
    async workflowExecutionsCombined(
        filter?: string,
        offset?: string,
        limit?: number,
        sort?: string,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ApiExecutionResultsResponse> {
        const response = await this.workflowExecutionsCombinedRaw({ filter: filter, offset: offset, limit: limit, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Gets one or more specific human inputs by their IDs.
     */
    async workflowGetHumanInputV1Raw(
        requestParameters: WorkflowsApiWorkflowGetHumanInputV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ModelUserInputReadResponse>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling workflowGetHumanInputV1().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/workflows/entities/human-inputs/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelUserInputReadResponseFromJSON(jsonValue));
    }

    /**
     * Gets one or more specific human inputs by their IDs.
     */
    async workflowGetHumanInputV1(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelUserInputReadResponse> {
        const response = await this.workflowGetHumanInputV1Raw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Executes a workflow definition with mocks
     */
    async workflowMockExecuteRaw(
        requestParameters: WorkflowsApiWorkflowMockExecuteRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiResourceIDsResponse>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling workflowMockExecute().');
        }

        const queryParameters: any = {};

        if (requestParameters["executionCid"] != null) {
            queryParameters["execution_cid"] = requestParameters["executionCid"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters["definitionId"] != null) {
            queryParameters["definition_id"] = requestParameters["definitionId"];
        }

        if (requestParameters["name"] != null) {
            queryParameters["name"] = requestParameters["name"];
        }

        if (requestParameters["key"] != null) {
            queryParameters["key"] = requestParameters["key"];
        }

        if (requestParameters["depth"] != null) {
            queryParameters["depth"] = requestParameters["depth"];
        }

        if (requestParameters["sourceEventUrl"] != null) {
            queryParameters["source_event_url"] = requestParameters["sourceEventUrl"];
        }

        if (requestParameters["validateOnly"] != null) {
            queryParameters["validate_only"] = requestParameters["validateOnly"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/workflows/entities/mock-executions/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: ModelsMockExecutionCreateRequestV1ToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiResourceIDsResponseFromJSON(jsonValue));
    }

    /**
     * Executes a workflow definition with mocks
     */
    async workflowMockExecute(
        body: ModelsMockExecutionCreateRequestV1,
        executionCid?: Array<string>,
        definitionId?: string,
        name?: string,
        key?: string,
        depth?: number,
        sourceEventUrl?: string,
        validateOnly?: boolean,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ApiResourceIDsResponse> {
        const response = await this.workflowMockExecuteRaw(
            { body: body, executionCid: executionCid, definitionId: definitionId, name: name, key: key, depth: depth, sourceEventUrl: sourceEventUrl, validateOnly: validateOnly },
            initOverrides,
        );
        return await response.value();
    }

    /**
     * Search for triggers by namespaced identifier, i.e. FalconAudit, Detection, or FalconAudit/Detection/Status. Returns all triggers if no filter specified
     */
    async workflowTriggersCombinedRaw(
        requestParameters: WorkflowsApiWorkflowTriggersCombinedRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<TriggersTriggerExternalResponse>> {
        const queryParameters: any = {};

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/workflows/combined/triggers/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => TriggersTriggerExternalResponseFromJSON(jsonValue));
    }

    /**
     * Search for triggers by namespaced identifier, i.e. FalconAudit, Detection, or FalconAudit/Detection/Status. Returns all triggers if no filter specified
     */
    async workflowTriggersCombined(filter?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TriggersTriggerExternalResponse> {
        const response = await this.workflowTriggersCombinedRaw({ filter: filter }, initOverrides);
        return await response.value();
    }

    /**
     * Provides an input in response to a human input action. Depending on action configuration, one or more of Approve, Decline, and/or Escalate are permitted.
     */
    async workflowUpdateHumanInputV1Raw(
        requestParameters: WorkflowsApiWorkflowUpdateHumanInputV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiResourceIDsResponse>> {
        if (requestParameters["id"] == null) {
            throw new runtime.RequiredError("id", 'Required parameter "id" was null or undefined when calling workflowUpdateHumanInputV1().');
        }

        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling workflowUpdateHumanInputV1().');
        }

        const queryParameters: any = {};

        if (requestParameters["id"] != null) {
            queryParameters["id"] = requestParameters["id"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/workflows/entities/human-inputs/v1`,
                method: "PATCH",
                headers: headerParameters,
                query: queryParameters,
                body: ModelUserInputUpdateRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiResourceIDsResponseFromJSON(jsonValue));
    }

    /**
     * Provides an input in response to a human input action. Depending on action configuration, one or more of Approve, Decline, and/or Escalate are permitted.
     */
    async workflowUpdateHumanInputV1(id: string, body: ModelUserInputUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiResourceIDsResponse> {
        const response = await this.workflowUpdateHumanInputV1Raw({ id: id, body: body }, initOverrides);
        return await response.value();
    }
}

/**
 * @export
 */
export const ExecutionActionActionNameEnum = {
    Resume: "resume",
} as const;
export type ExecutionActionActionNameEnum = (typeof ExecutionActionActionNameEnum)[keyof typeof ExecutionActionActionNameEnum];
