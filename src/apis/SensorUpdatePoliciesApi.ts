/* tslint:disable */
/* eslint-disable */
/**
 * CrowdStrike API Specification
 * Use this API specification as a reference for the API endpoints you can use to interact with your Falcon environment. These endpoints support authentication via OAuth2 and interact with detections and network containment. For detailed usage guides and examples, see our [documentation inside the Falcon console](https://falcon.crowdstrike.com/support/documentation).     To use the APIs described below, combine the base URL with the path shown for each API endpoint. For commercial cloud customers, your base URL is `https://api.crowdstrike.com`.    Each API endpoint requires authorization via an OAuth2 token. Your first API request should retrieve an OAuth2 token using the `oauth2/token` endpoint, such as `https://api.crowdstrike.com/oauth2/token`. For subsequent requests, include the OAuth2 token in an HTTP authorization header. Tokens expire after 30 minutes, after which you should make a new token request to continue making API requests.
 *
 * The version of the OpenAPI document: rolling
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
    BasePolicyMembersRespV1,
    BaseSetPolicyPrecedenceReqV1,
    MsaEntityActionRequestV2,
    MsaErrorsOnly,
    MsaQueryResponse,
    MsaReplyMetaOnly,
    SensorUpdateBuildsRespV1,
    SensorUpdateCreatePoliciesReqV1,
    SensorUpdateCreatePoliciesReqV2,
    SensorUpdateKernelsRespV1,
    SensorUpdateRespV1,
    SensorUpdateRespV2,
    SensorUpdateUpdatePoliciesReqV1,
    SensorUpdateUpdatePoliciesReqV2,
    UninstallTokenRespV1,
    UninstallTokenRevealUninstallTokenReqV1,
} from "../models/index";
import {
    BasePolicyMembersRespV1FromJSON,
    BasePolicyMembersRespV1ToJSON,
    BaseSetPolicyPrecedenceReqV1FromJSON,
    BaseSetPolicyPrecedenceReqV1ToJSON,
    MsaEntityActionRequestV2FromJSON,
    MsaEntityActionRequestV2ToJSON,
    MsaErrorsOnlyFromJSON,
    MsaErrorsOnlyToJSON,
    MsaQueryResponseFromJSON,
    MsaQueryResponseToJSON,
    MsaReplyMetaOnlyFromJSON,
    MsaReplyMetaOnlyToJSON,
    SensorUpdateBuildsRespV1FromJSON,
    SensorUpdateBuildsRespV1ToJSON,
    SensorUpdateCreatePoliciesReqV1FromJSON,
    SensorUpdateCreatePoliciesReqV1ToJSON,
    SensorUpdateCreatePoliciesReqV2FromJSON,
    SensorUpdateCreatePoliciesReqV2ToJSON,
    SensorUpdateKernelsRespV1FromJSON,
    SensorUpdateKernelsRespV1ToJSON,
    SensorUpdateRespV1FromJSON,
    SensorUpdateRespV1ToJSON,
    SensorUpdateRespV2FromJSON,
    SensorUpdateRespV2ToJSON,
    SensorUpdateUpdatePoliciesReqV1FromJSON,
    SensorUpdateUpdatePoliciesReqV1ToJSON,
    SensorUpdateUpdatePoliciesReqV2FromJSON,
    SensorUpdateUpdatePoliciesReqV2ToJSON,
    UninstallTokenRespV1FromJSON,
    UninstallTokenRespV1ToJSON,
    UninstallTokenRevealUninstallTokenReqV1FromJSON,
    UninstallTokenRevealUninstallTokenReqV1ToJSON,
} from "../models/index";

export interface CreateSensorUpdatePoliciesRequest {
    body: SensorUpdateCreatePoliciesReqV1;
}

export interface CreateSensorUpdatePoliciesV2Request {
    body: SensorUpdateCreatePoliciesReqV2;
}

export interface DeleteSensorUpdatePoliciesRequest {
    ids: Array<string>;
}

export interface GetSensorUpdatePoliciesRequest {
    ids: Array<string>;
}

export interface GetSensorUpdatePoliciesV2Request {
    ids: Array<string>;
}

export interface PerformSensorUpdatePoliciesActionRequest {
    actionName: PerformSensorUpdatePoliciesActionActionNameEnum;
    body: MsaEntityActionRequestV2;
}

export interface QueryCombinedSensorUpdateBuildsRequest {
    platform?: QueryCombinedSensorUpdateBuildsPlatformEnum;
    stage?: QueryCombinedSensorUpdateBuildsStageEnum;
}

export interface QueryCombinedSensorUpdateKernelsRequest {
    filter?: string;
    offset?: number;
    limit?: number;
}

export interface QueryCombinedSensorUpdatePoliciesRequest {
    filter?: string;
    offset?: number;
    limit?: number;
    sort?: QueryCombinedSensorUpdatePoliciesSortEnum;
}

export interface QueryCombinedSensorUpdatePoliciesV2Request {
    filter?: string;
    offset?: number;
    limit?: number;
    sort?: QueryCombinedSensorUpdatePoliciesV2SortEnum;
}

export interface QueryCombinedSensorUpdatePolicyMembersRequest {
    id?: string;
    filter?: string;
    offset?: number;
    limit?: number;
    sort?: string;
}

export interface QuerySensorUpdateKernelsDistinctRequest {
    distinctField: string;
    filter?: string;
    offset?: number;
    limit?: number;
}

export interface QuerySensorUpdatePoliciesRequest {
    filter?: string;
    offset?: number;
    limit?: number;
    sort?: QuerySensorUpdatePoliciesSortEnum;
}

export interface QuerySensorUpdatePolicyMembersRequest {
    id?: string;
    filter?: string;
    offset?: number;
    limit?: number;
    sort?: string;
}

export interface RevealUninstallTokenRequest {
    body: UninstallTokenRevealUninstallTokenReqV1;
}

export interface SetSensorUpdatePoliciesPrecedenceRequest {
    body: BaseSetPolicyPrecedenceReqV1;
}

export interface UpdateSensorUpdatePoliciesRequest {
    body: SensorUpdateUpdatePoliciesReqV1;
}

export interface UpdateSensorUpdatePoliciesV2Request {
    body: SensorUpdateUpdatePoliciesReqV2;
}

/**
 *
 */
export class SensorUpdatePoliciesApi extends runtime.BaseAPI {
    /**
     * Create Sensor Update Policies by specifying details about the policy to create
     */
    async createSensorUpdatePoliciesRaw(
        requestParameters: CreateSensorUpdatePoliciesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<SensorUpdateRespV1>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError("body", "Required parameter requestParameters.body was null or undefined when calling createSensorUpdatePolicies.");
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/entities/sensor-update/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: SensorUpdateCreatePoliciesReqV1ToJSON(requestParameters.body),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => SensorUpdateRespV1FromJSON(jsonValue));
    }

    /**
     * Create Sensor Update Policies by specifying details about the policy to create
     */
    async createSensorUpdatePolicies(body: SensorUpdateCreatePoliciesReqV1, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SensorUpdateRespV1> {
        const response = await this.createSensorUpdatePoliciesRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Create Sensor Update Policies by specifying details about the policy to create with additional support for uninstall protection
     */
    async createSensorUpdatePoliciesV2Raw(
        requestParameters: CreateSensorUpdatePoliciesV2Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<SensorUpdateRespV2>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError("body", "Required parameter requestParameters.body was null or undefined when calling createSensorUpdatePoliciesV2.");
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/entities/sensor-update/v2`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: SensorUpdateCreatePoliciesReqV2ToJSON(requestParameters.body),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => SensorUpdateRespV2FromJSON(jsonValue));
    }

    /**
     * Create Sensor Update Policies by specifying details about the policy to create with additional support for uninstall protection
     */
    async createSensorUpdatePoliciesV2(body: SensorUpdateCreatePoliciesReqV2, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SensorUpdateRespV2> {
        const response = await this.createSensorUpdatePoliciesV2Raw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Delete a set of Sensor Update Policies by specifying their IDs
     */
    async deleteSensorUpdatePoliciesRaw(
        requestParameters: DeleteSensorUpdatePoliciesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<MsaQueryResponse>> {
        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError("ids", "Required parameter requestParameters.ids was null or undefined when calling deleteSensorUpdatePolicies.");
        }

        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters["ids"] = requestParameters.ids;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/entities/sensor-update/v1`,
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaQueryResponseFromJSON(jsonValue));
    }

    /**
     * Delete a set of Sensor Update Policies by specifying their IDs
     */
    async deleteSensorUpdatePolicies(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MsaQueryResponse> {
        const response = await this.deleteSensorUpdatePoliciesRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a set of Sensor Update Policies by specifying their IDs
     */
    async getSensorUpdatePoliciesRaw(requestParameters: GetSensorUpdatePoliciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SensorUpdateRespV1>> {
        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError("ids", "Required parameter requestParameters.ids was null or undefined when calling getSensorUpdatePolicies.");
        }

        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters["ids"] = requestParameters.ids;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/entities/sensor-update/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => SensorUpdateRespV1FromJSON(jsonValue));
    }

    /**
     * Retrieve a set of Sensor Update Policies by specifying their IDs
     */
    async getSensorUpdatePolicies(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SensorUpdateRespV1> {
        const response = await this.getSensorUpdatePoliciesRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a set of Sensor Update Policies with additional support for uninstall protection by specifying their IDs
     */
    async getSensorUpdatePoliciesV2Raw(
        requestParameters: GetSensorUpdatePoliciesV2Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<SensorUpdateRespV2>> {
        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError("ids", "Required parameter requestParameters.ids was null or undefined when calling getSensorUpdatePoliciesV2.");
        }

        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters["ids"] = requestParameters.ids;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/entities/sensor-update/v2`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => SensorUpdateRespV2FromJSON(jsonValue));
    }

    /**
     * Retrieve a set of Sensor Update Policies with additional support for uninstall protection by specifying their IDs
     */
    async getSensorUpdatePoliciesV2(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SensorUpdateRespV2> {
        const response = await this.getSensorUpdatePoliciesV2Raw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Perform the specified action on the Sensor Update Policies specified in the request
     */
    async performSensorUpdatePoliciesActionRaw(
        requestParameters: PerformSensorUpdatePoliciesActionRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<SensorUpdateRespV1>> {
        if (requestParameters.actionName === null || requestParameters.actionName === undefined) {
            throw new runtime.RequiredError("actionName", "Required parameter requestParameters.actionName was null or undefined when calling performSensorUpdatePoliciesAction.");
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError("body", "Required parameter requestParameters.body was null or undefined when calling performSensorUpdatePoliciesAction.");
        }

        const queryParameters: any = {};

        if (requestParameters.actionName !== undefined) {
            queryParameters["action_name"] = requestParameters.actionName;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/entities/sensor-update-actions/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: MsaEntityActionRequestV2ToJSON(requestParameters.body),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => SensorUpdateRespV1FromJSON(jsonValue));
    }

    /**
     * Perform the specified action on the Sensor Update Policies specified in the request
     */
    async performSensorUpdatePoliciesAction(
        actionName: PerformSensorUpdatePoliciesActionActionNameEnum,
        body: MsaEntityActionRequestV2,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<SensorUpdateRespV1> {
        const response = await this.performSensorUpdatePoliciesActionRaw({ actionName: actionName, body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve available builds for use with Sensor Update Policies
     */
    async queryCombinedSensorUpdateBuildsRaw(
        requestParameters: QueryCombinedSensorUpdateBuildsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<SensorUpdateBuildsRespV1>> {
        const queryParameters: any = {};

        if (requestParameters.platform !== undefined) {
            queryParameters["platform"] = requestParameters.platform;
        }

        if (requestParameters.stage) {
            queryParameters["stage"] = requestParameters.stage.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/combined/sensor-update-builds/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => SensorUpdateBuildsRespV1FromJSON(jsonValue));
    }

    /**
     * Retrieve available builds for use with Sensor Update Policies
     */
    async queryCombinedSensorUpdateBuilds(
        platform?: QueryCombinedSensorUpdateBuildsPlatformEnum,
        stage?: QueryCombinedSensorUpdateBuildsStageEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<SensorUpdateBuildsRespV1> {
        const response = await this.queryCombinedSensorUpdateBuildsRaw({ platform: platform, stage: stage }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve kernel compatibility info for Sensor Update Builds
     */
    async queryCombinedSensorUpdateKernelsRaw(
        requestParameters: QueryCombinedSensorUpdateKernelsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<SensorUpdateKernelsRespV1>> {
        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/combined/sensor-update-kernels/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => SensorUpdateKernelsRespV1FromJSON(jsonValue));
    }

    /**
     * Retrieve kernel compatibility info for Sensor Update Builds
     */
    async queryCombinedSensorUpdateKernels(filter?: string, offset?: number, limit?: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SensorUpdateKernelsRespV1> {
        const response = await this.queryCombinedSensorUpdateKernelsRaw({ filter: filter, offset: offset, limit: limit }, initOverrides);
        return await response.value();
    }

    /**
     * Search for Sensor Update Policies in your environment by providing an FQL filter and paging details. Returns a set of Sensor Update Policies which match the filter criteria
     */
    async queryCombinedSensorUpdatePoliciesRaw(
        requestParameters: QueryCombinedSensorUpdatePoliciesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<SensorUpdateRespV1>> {
        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/combined/sensor-update/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => SensorUpdateRespV1FromJSON(jsonValue));
    }

    /**
     * Search for Sensor Update Policies in your environment by providing an FQL filter and paging details. Returns a set of Sensor Update Policies which match the filter criteria
     */
    async queryCombinedSensorUpdatePolicies(
        filter?: string,
        offset?: number,
        limit?: number,
        sort?: QueryCombinedSensorUpdatePoliciesSortEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<SensorUpdateRespV1> {
        const response = await this.queryCombinedSensorUpdatePoliciesRaw({ filter: filter, offset: offset, limit: limit, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Search for Sensor Update Policies with additional support for uninstall protection in your environment by providing an FQL filter and paging details. Returns a set of Sensor Update Policies which match the filter criteria
     */
    async queryCombinedSensorUpdatePoliciesV2Raw(
        requestParameters: QueryCombinedSensorUpdatePoliciesV2Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<SensorUpdateRespV2>> {
        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/combined/sensor-update/v2`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => SensorUpdateRespV2FromJSON(jsonValue));
    }

    /**
     * Search for Sensor Update Policies with additional support for uninstall protection in your environment by providing an FQL filter and paging details. Returns a set of Sensor Update Policies which match the filter criteria
     */
    async queryCombinedSensorUpdatePoliciesV2(
        filter?: string,
        offset?: number,
        limit?: number,
        sort?: QueryCombinedSensorUpdatePoliciesV2SortEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<SensorUpdateRespV2> {
        const response = await this.queryCombinedSensorUpdatePoliciesV2Raw({ filter: filter, offset: offset, limit: limit, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Search for members of a Sensor Update Policy in your environment by providing an FQL filter and paging details. Returns a set of host details which match the filter criteria
     */
    async queryCombinedSensorUpdatePolicyMembersRaw(
        requestParameters: QueryCombinedSensorUpdatePolicyMembersRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<BasePolicyMembersRespV1>> {
        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters["id"] = requestParameters.id;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/combined/sensor-update-members/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => BasePolicyMembersRespV1FromJSON(jsonValue));
    }

    /**
     * Search for members of a Sensor Update Policy in your environment by providing an FQL filter and paging details. Returns a set of host details which match the filter criteria
     */
    async queryCombinedSensorUpdatePolicyMembers(
        id?: string,
        filter?: string,
        offset?: number,
        limit?: number,
        sort?: string,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<BasePolicyMembersRespV1> {
        const response = await this.queryCombinedSensorUpdatePolicyMembersRaw({ id: id, filter: filter, offset: offset, limit: limit, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve kernel compatibility info for Sensor Update Builds
     */
    async querySensorUpdateKernelsDistinctRaw(
        requestParameters: QuerySensorUpdateKernelsDistinctRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<MsaQueryResponse>> {
        if (requestParameters.distinctField === null || requestParameters.distinctField === undefined) {
            throw new runtime.RequiredError("distinctField", "Required parameter requestParameters.distinctField was null or undefined when calling querySensorUpdateKernelsDistinct.");
        }

        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/queries/sensor-update-kernels/{distinct_field}/v1`.replace(`{${"distinct_field"}}`, encodeURIComponent(String(requestParameters.distinctField))),
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaQueryResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve kernel compatibility info for Sensor Update Builds
     */
    async querySensorUpdateKernelsDistinct(
        distinctField: string,
        filter?: string,
        offset?: number,
        limit?: number,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<MsaQueryResponse> {
        const response = await this.querySensorUpdateKernelsDistinctRaw({ distinctField: distinctField, filter: filter, offset: offset, limit: limit }, initOverrides);
        return await response.value();
    }

    /**
     * Search for Sensor Update Policies in your environment by providing an FQL filter and paging details. Returns a set of Sensor Update Policy IDs which match the filter criteria
     */
    async querySensorUpdatePoliciesRaw(
        requestParameters: QuerySensorUpdatePoliciesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<MsaQueryResponse>> {
        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/queries/sensor-update/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaQueryResponseFromJSON(jsonValue));
    }

    /**
     * Search for Sensor Update Policies in your environment by providing an FQL filter and paging details. Returns a set of Sensor Update Policy IDs which match the filter criteria
     */
    async querySensorUpdatePolicies(
        filter?: string,
        offset?: number,
        limit?: number,
        sort?: QuerySensorUpdatePoliciesSortEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<MsaQueryResponse> {
        const response = await this.querySensorUpdatePoliciesRaw({ filter: filter, offset: offset, limit: limit, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Search for members of a Sensor Update Policy in your environment by providing an FQL filter and paging details. Returns a set of Agent IDs which match the filter criteria
     */
    async querySensorUpdatePolicyMembersRaw(
        requestParameters: QuerySensorUpdatePolicyMembersRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<MsaQueryResponse>> {
        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters["id"] = requestParameters.id;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/queries/sensor-update-members/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaQueryResponseFromJSON(jsonValue));
    }

    /**
     * Search for members of a Sensor Update Policy in your environment by providing an FQL filter and paging details. Returns a set of Agent IDs which match the filter criteria
     */
    async querySensorUpdatePolicyMembers(
        id?: string,
        filter?: string,
        offset?: number,
        limit?: number,
        sort?: string,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<MsaQueryResponse> {
        const response = await this.querySensorUpdatePolicyMembersRaw({ id: id, filter: filter, offset: offset, limit: limit, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Reveals an uninstall token for a specific device. To retrieve the bulk maintenance token pass the value \'MAINTENANCE\' as the value for \'device_id\'
     */
    async revealUninstallTokenRaw(requestParameters: RevealUninstallTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UninstallTokenRespV1>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError("body", "Required parameter requestParameters.body was null or undefined when calling revealUninstallToken.");
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/combined/reveal-uninstall-token/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: UninstallTokenRevealUninstallTokenReqV1ToJSON(requestParameters.body),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => UninstallTokenRespV1FromJSON(jsonValue));
    }

    /**
     * Reveals an uninstall token for a specific device. To retrieve the bulk maintenance token pass the value \'MAINTENANCE\' as the value for \'device_id\'
     */
    async revealUninstallToken(body: UninstallTokenRevealUninstallTokenReqV1, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UninstallTokenRespV1> {
        const response = await this.revealUninstallTokenRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Sets the precedence of Sensor Update Policies based on the order of IDs specified in the request. The first ID specified will have the highest precedence and the last ID specified will have the lowest. You must specify all non-Default Policies for a platform when updating precedence
     */
    async setSensorUpdatePoliciesPrecedenceRaw(
        requestParameters: SetSensorUpdatePoliciesPrecedenceRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<MsaQueryResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError("body", "Required parameter requestParameters.body was null or undefined when calling setSensorUpdatePoliciesPrecedence.");
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/entities/sensor-update-precedence/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: BaseSetPolicyPrecedenceReqV1ToJSON(requestParameters.body),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaQueryResponseFromJSON(jsonValue));
    }

    /**
     * Sets the precedence of Sensor Update Policies based on the order of IDs specified in the request. The first ID specified will have the highest precedence and the last ID specified will have the lowest. You must specify all non-Default Policies for a platform when updating precedence
     */
    async setSensorUpdatePoliciesPrecedence(body: BaseSetPolicyPrecedenceReqV1, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MsaQueryResponse> {
        const response = await this.setSensorUpdatePoliciesPrecedenceRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Update Sensor Update Policies by specifying the ID of the policy and details to update
     */
    async updateSensorUpdatePoliciesRaw(
        requestParameters: UpdateSensorUpdatePoliciesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<SensorUpdateRespV1>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError("body", "Required parameter requestParameters.body was null or undefined when calling updateSensorUpdatePolicies.");
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/entities/sensor-update/v1`,
                method: "PATCH",
                headers: headerParameters,
                query: queryParameters,
                body: SensorUpdateUpdatePoliciesReqV1ToJSON(requestParameters.body),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => SensorUpdateRespV1FromJSON(jsonValue));
    }

    /**
     * Update Sensor Update Policies by specifying the ID of the policy and details to update
     */
    async updateSensorUpdatePolicies(body: SensorUpdateUpdatePoliciesReqV1, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SensorUpdateRespV1> {
        const response = await this.updateSensorUpdatePoliciesRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Update Sensor Update Policies by specifying the ID of the policy and details to update with additional support for uninstall protection
     */
    async updateSensorUpdatePoliciesV2Raw(
        requestParameters: UpdateSensorUpdatePoliciesV2Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<SensorUpdateRespV2>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError("body", "Required parameter requestParameters.body was null or undefined when calling updateSensorUpdatePoliciesV2.");
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/policy/entities/sensor-update/v2`,
                method: "PATCH",
                headers: headerParameters,
                query: queryParameters,
                body: SensorUpdateUpdatePoliciesReqV2ToJSON(requestParameters.body),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => SensorUpdateRespV2FromJSON(jsonValue));
    }

    /**
     * Update Sensor Update Policies by specifying the ID of the policy and details to update with additional support for uninstall protection
     */
    async updateSensorUpdatePoliciesV2(body: SensorUpdateUpdatePoliciesReqV2, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SensorUpdateRespV2> {
        const response = await this.updateSensorUpdatePoliciesV2Raw({ body: body }, initOverrides);
        return await response.value();
    }
}

/**
 * @export
 */
export const PerformSensorUpdatePoliciesActionActionNameEnum = {
    AddHostGroup: "add-host-group",
    AddRuleGroup: "add-rule-group",
    Disable: "disable",
    Enable: "enable",
    RemoveHostGroup: "remove-host-group",
    RemoveRuleGroup: "remove-rule-group",
} as const;
export type PerformSensorUpdatePoliciesActionActionNameEnum = (typeof PerformSensorUpdatePoliciesActionActionNameEnum)[keyof typeof PerformSensorUpdatePoliciesActionActionNameEnum];
/**
 * @export
 */
export const QueryCombinedSensorUpdateBuildsPlatformEnum = {
    Linux: "linux",
    Linuxarm64: "linuxarm64",
    Mac: "mac",
    Windows: "windows",
    Zlinux: "zlinux",
} as const;
export type QueryCombinedSensorUpdateBuildsPlatformEnum = (typeof QueryCombinedSensorUpdateBuildsPlatformEnum)[keyof typeof QueryCombinedSensorUpdateBuildsPlatformEnum];
/**
 * @export
 */
export const QueryCombinedSensorUpdateBuildsStageEnum = {} as const;
export type QueryCombinedSensorUpdateBuildsStageEnum = Array<String>;
/**
 * @export
 */
export const QueryCombinedSensorUpdatePoliciesSortEnum = {
    CreatedByAsc: "created_by.asc",
    CreatedByDesc: "created_by.desc",
    CreatedTimestampAsc: "created_timestamp.asc",
    CreatedTimestampDesc: "created_timestamp.desc",
    EnabledAsc: "enabled.asc",
    EnabledDesc: "enabled.desc",
    ModifiedByAsc: "modified_by.asc",
    ModifiedByDesc: "modified_by.desc",
    ModifiedTimestampAsc: "modified_timestamp.asc",
    ModifiedTimestampDesc: "modified_timestamp.desc",
    NameAsc: "name.asc",
    NameDesc: "name.desc",
    PlatformNameAsc: "platform_name.asc",
    PlatformNameDesc: "platform_name.desc",
    PrecedenceAsc: "precedence.asc",
    PrecedenceDesc: "precedence.desc",
} as const;
export type QueryCombinedSensorUpdatePoliciesSortEnum = (typeof QueryCombinedSensorUpdatePoliciesSortEnum)[keyof typeof QueryCombinedSensorUpdatePoliciesSortEnum];
/**
 * @export
 */
export const QueryCombinedSensorUpdatePoliciesV2SortEnum = {
    CreatedByAsc: "created_by.asc",
    CreatedByDesc: "created_by.desc",
    CreatedTimestampAsc: "created_timestamp.asc",
    CreatedTimestampDesc: "created_timestamp.desc",
    EnabledAsc: "enabled.asc",
    EnabledDesc: "enabled.desc",
    ModifiedByAsc: "modified_by.asc",
    ModifiedByDesc: "modified_by.desc",
    ModifiedTimestampAsc: "modified_timestamp.asc",
    ModifiedTimestampDesc: "modified_timestamp.desc",
    NameAsc: "name.asc",
    NameDesc: "name.desc",
    PlatformNameAsc: "platform_name.asc",
    PlatformNameDesc: "platform_name.desc",
    PrecedenceAsc: "precedence.asc",
    PrecedenceDesc: "precedence.desc",
} as const;
export type QueryCombinedSensorUpdatePoliciesV2SortEnum = (typeof QueryCombinedSensorUpdatePoliciesV2SortEnum)[keyof typeof QueryCombinedSensorUpdatePoliciesV2SortEnum];
/**
 * @export
 */
export const QuerySensorUpdatePoliciesSortEnum = {
    CreatedByAsc: "created_by.asc",
    CreatedByDesc: "created_by.desc",
    CreatedTimestampAsc: "created_timestamp.asc",
    CreatedTimestampDesc: "created_timestamp.desc",
    EnabledAsc: "enabled.asc",
    EnabledDesc: "enabled.desc",
    ModifiedByAsc: "modified_by.asc",
    ModifiedByDesc: "modified_by.desc",
    ModifiedTimestampAsc: "modified_timestamp.asc",
    ModifiedTimestampDesc: "modified_timestamp.desc",
    NameAsc: "name.asc",
    NameDesc: "name.desc",
    PlatformNameAsc: "platform_name.asc",
    PlatformNameDesc: "platform_name.desc",
    PrecedenceAsc: "precedence.asc",
    PrecedenceDesc: "precedence.desc",
} as const;
export type QuerySensorUpdatePoliciesSortEnum = (typeof QuerySensorUpdatePoliciesSortEnum)[keyof typeof QuerySensorUpdatePoliciesSortEnum];
