/* tslint:disable */
/* eslint-disable */
/**
 * CrowdStrike API Specification
 * Use this API specification as a reference for the API endpoints you can use to interact with your Falcon environment. These endpoints support authentication via OAuth2 and interact with detections and network containment. For detailed usage guides and examples, see our [documentation inside the Falcon console](https://falcon.crowdstrike.com/support/documentation).     To use the APIs described below, combine the base URL with the path shown for each API endpoint. For commercial cloud customers, your base URL is `https://api.crowdstrike.com`.    Each API endpoint requires authorization via an OAuth2 token. Your first API request should retrieve an OAuth2 token using the `oauth2/token` endpoint, such as `https://api.crowdstrike.com/oauth2/token`. For subsequent requests, include the OAuth2 token in an HTTP authorization header. Tokens expire after 30 minutes, after which you should make a new token request to continue making API requests.
 *
 * The version of the OpenAPI document: rolling
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
    DomainActorsResponse,
    DomainNewsResponse,
    DomainPublicIndicatorsV3Response,
    DomainQueryMitreAttacksResponse,
    DomainRulesResponse,
    DomainVulnerabilityResponse,
    MsaErrorsOnly,
    MsaIdsRequest,
    MsaQueryResponse,
    MsaReplyMetaOnly,
} from "../models/index";
import {
    DomainActorsResponseFromJSON,
    DomainActorsResponseToJSON,
    DomainNewsResponseFromJSON,
    DomainNewsResponseToJSON,
    DomainPublicIndicatorsV3ResponseFromJSON,
    DomainPublicIndicatorsV3ResponseToJSON,
    DomainQueryMitreAttacksResponseFromJSON,
    DomainQueryMitreAttacksResponseToJSON,
    DomainRulesResponseFromJSON,
    DomainRulesResponseToJSON,
    DomainVulnerabilityResponseFromJSON,
    DomainVulnerabilityResponseToJSON,
    MsaErrorsOnlyFromJSON,
    MsaErrorsOnlyToJSON,
    MsaIdsRequestFromJSON,
    MsaIdsRequestToJSON,
    MsaQueryResponseFromJSON,
    MsaQueryResponseToJSON,
    MsaReplyMetaOnlyFromJSON,
    MsaReplyMetaOnlyToJSON,
} from "../models/index";

export interface GetIntelActorEntitiesRequest {
    ids: Array<string>;
    fields?: Array<string>;
}

export interface GetIntelIndicatorEntitiesRequest {
    body: MsaIdsRequest;
}

export interface GetIntelReportEntitiesRequest {
    ids: Array<string>;
    fields?: Array<string>;
}

export interface GetIntelReportPDFRequest {
    id?: string;
    ids?: string;
}

export interface GetIntelRuleEntitiesRequest {
    ids: Array<string>;
}

export interface GetIntelRuleFileRequest {
    id: number;
    accept?: string;
    format?: string;
}

export interface GetLatestIntelRuleFileRequest {
    type: string;
    accept?: string;
    ifNoneMatch?: string;
    ifModifiedSince?: string;
    format?: string;
    ifModifiedSince2?: string;
}

export interface GetMitreReportRequest {
    actorId: string;
    format: string;
}

export interface IntelApiGetVulnerabilitiesRequest {
    body: MsaIdsRequest;
}

export interface PostMitreAttacksRequest {
    body: MsaIdsRequest;
}

export interface QueryIntelActorEntitiesRequest {
    offset?: number;
    limit?: number;
    sort?: string;
    filter?: string;
    q?: string;
    fields?: Array<string>;
}

export interface QueryIntelActorIdsRequest {
    offset?: number;
    limit?: number;
    sort?: string;
    filter?: string;
    q?: string;
}

export interface QueryIntelIndicatorEntitiesRequest {
    offset?: number;
    limit?: number;
    sort?: string;
    filter?: string;
    q?: string;
    includeDeleted?: boolean;
    includeRelations?: boolean;
}

export interface QueryIntelIndicatorIdsRequest {
    offset?: number;
    limit?: number;
    sort?: string;
    filter?: string;
    q?: string;
    includeDeleted?: boolean;
    includeRelations?: boolean;
}

export interface QueryIntelReportEntitiesRequest {
    offset?: number;
    limit?: number;
    sort?: string;
    filter?: string;
    q?: string;
    fields?: Array<string>;
}

export interface QueryIntelReportIdsRequest {
    offset?: number;
    limit?: number;
    sort?: string;
    filter?: string;
    q?: string;
}

export interface QueryIntelRuleIdsRequest {
    type: string;
    offset?: number;
    limit?: number;
    sort?: string;
    name?: Array<string>;
    description?: Array<string>;
    tags?: Array<string>;
    minCreatedDate?: number;
    maxCreatedDate?: string;
    q?: string;
}

export interface QueryMitreAttacksRequest {
    id?: string;
    ids?: Array<string>;
}

export interface IntelApiQueryVulnerabilitiesRequest {
    offset?: string;
    limit?: number;
    sort?: string;
    filter?: string;
    q?: string;
}

/**
 *
 */
export class IntelApi extends runtime.BaseAPI {
    /**
     * Retrieve specific actors using their actor IDs.
     */
    async getIntelActorEntitiesRaw(requestParameters: GetIntelActorEntitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DomainActorsResponse>> {
        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError("ids", "Required parameter requestParameters.ids was null or undefined when calling getIntelActorEntities.");
        }

        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters["ids"] = requestParameters.ids;
        }

        if (requestParameters.fields) {
            queryParameters["fields"] = requestParameters.fields;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/entities/actors/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainActorsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve specific actors using their actor IDs.
     */
    async getIntelActorEntities(ids: Array<string>, fields?: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainActorsResponse> {
        const response = await this.getIntelActorEntitiesRaw({ ids: ids, fields: fields }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve specific indicators using their indicator IDs.
     */
    async getIntelIndicatorEntitiesRaw(
        requestParameters: GetIntelIndicatorEntitiesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<DomainPublicIndicatorsV3Response>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError("body", "Required parameter requestParameters.body was null or undefined when calling getIntelIndicatorEntities.");
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/entities/indicators/GET/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: MsaIdsRequestToJSON(requestParameters.body),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainPublicIndicatorsV3ResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve specific indicators using their indicator IDs.
     */
    async getIntelIndicatorEntities(body: MsaIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainPublicIndicatorsV3Response> {
        const response = await this.getIntelIndicatorEntitiesRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve specific reports using their report IDs.
     */
    async getIntelReportEntitiesRaw(requestParameters: GetIntelReportEntitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DomainNewsResponse>> {
        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError("ids", "Required parameter requestParameters.ids was null or undefined when calling getIntelReportEntities.");
        }

        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters["ids"] = requestParameters.ids;
        }

        if (requestParameters.fields) {
            queryParameters["fields"] = requestParameters.fields;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/entities/reports/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainNewsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve specific reports using their report IDs.
     */
    async getIntelReportEntities(ids: Array<string>, fields?: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainNewsResponse> {
        const response = await this.getIntelReportEntitiesRaw({ ids: ids, fields: fields }, initOverrides);
        return await response.value();
    }

    /**
     * Return a Report PDF attachment
     */
    async getIntelReportPDFRaw(requestParameters: GetIntelReportPDFRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters["id"] = requestParameters.id;
        }

        if (requestParameters.ids !== undefined) {
            queryParameters["ids"] = requestParameters.ids;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/entities/report-files/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Return a Report PDF attachment
     */
    async getIntelReportPDF(id?: string, ids?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.getIntelReportPDFRaw({ id: id, ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve details for rule sets for the specified ids.
     */
    async getIntelRuleEntitiesRaw(requestParameters: GetIntelRuleEntitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DomainRulesResponse>> {
        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError("ids", "Required parameter requestParameters.ids was null or undefined when calling getIntelRuleEntities.");
        }

        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters["ids"] = requestParameters.ids;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/entities/rules/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainRulesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve details for rule sets for the specified ids.
     */
    async getIntelRuleEntities(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainRulesResponse> {
        const response = await this.getIntelRuleEntitiesRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Download earlier rule sets.
     */
    async getIntelRuleFileRaw(requestParameters: GetIntelRuleFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling getIntelRuleFile.");
        }

        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters["id"] = requestParameters.id;
        }

        if (requestParameters.format !== undefined) {
            queryParameters["format"] = requestParameters.format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters["Accept"] = String(requestParameters.accept);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/entities/rules-files/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Download earlier rule sets.
     */
    async getIntelRuleFile(id: number, accept?: string, format?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.getIntelRuleFileRaw({ id: id, accept: accept, format: format }, initOverrides);
        return await response.value();
    }

    /**
     * Download the latest rule set.
     */
    async getLatestIntelRuleFileRaw(requestParameters: GetLatestIntelRuleFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError("type", "Required parameter requestParameters.type was null or undefined when calling getLatestIntelRuleFile.");
        }

        const queryParameters: any = {};

        if (requestParameters.type !== undefined) {
            queryParameters["type"] = requestParameters.type;
        }

        if (requestParameters.format !== undefined) {
            queryParameters["format"] = requestParameters.format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters["Accept"] = String(requestParameters.accept);
        }

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters["If-None-Match"] = String(requestParameters.ifNoneMatch);
        }

        if (requestParameters.ifModifiedSince !== undefined && requestParameters.ifModifiedSince !== null) {
            headerParameters["If-Modified-Since"] = String(requestParameters.ifModifiedSince);
        }

        if (requestParameters.ifModifiedSince2 !== undefined && requestParameters.ifModifiedSince2 !== null) {
            headerParameters["If-Modified-Since"] = String(requestParameters.ifModifiedSince2);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/entities/rules-latest-files/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Download the latest rule set.
     */
    async getLatestIntelRuleFile(
        type: string,
        accept?: string,
        ifNoneMatch?: string,
        ifModifiedSince?: string,
        format?: string,
        ifModifiedSince2?: string,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<Blob> {
        const response = await this.getLatestIntelRuleFileRaw(
            { type: type, accept: accept, ifNoneMatch: ifNoneMatch, ifModifiedSince: ifModifiedSince, format: format, ifModifiedSince2: ifModifiedSince2 },
            initOverrides
        );
        return await response.value();
    }

    /**
     * Export Mitre ATT&CK information for a given actor.
     */
    async getMitreReportRaw(requestParameters: GetMitreReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.actorId === null || requestParameters.actorId === undefined) {
            throw new runtime.RequiredError("actorId", "Required parameter requestParameters.actorId was null or undefined when calling getMitreReport.");
        }

        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError("format", "Required parameter requestParameters.format was null or undefined when calling getMitreReport.");
        }

        const queryParameters: any = {};

        if (requestParameters.actorId !== undefined) {
            queryParameters["actor_id"] = requestParameters.actorId;
        }

        if (requestParameters.format !== undefined) {
            queryParameters["format"] = requestParameters.format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/entities/mitre-reports/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Export Mitre ATT&CK information for a given actor.
     */
    async getMitreReport(actorId: string, format: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getMitreReportRaw({ actorId: actorId, format: format }, initOverrides);
    }

    /**
     * Get vulnerabilities
     */
    async getVulnerabilitiesRaw(
        requestParameters: IntelApiGetVulnerabilitiesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<DomainVulnerabilityResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError("body", "Required parameter requestParameters.body was null or undefined when calling getVulnerabilities.");
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/entities/vulnerabilities/GET/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: MsaIdsRequestToJSON(requestParameters.body),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainVulnerabilityResponseFromJSON(jsonValue));
    }

    /**
     * Get vulnerabilities
     */
    async getVulnerabilities(body: MsaIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainVulnerabilityResponse> {
        const response = await this.getVulnerabilitiesRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves report and observable IDs associated with the given actor and attacks
     */
    async postMitreAttacksRaw(requestParameters: PostMitreAttacksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError("body", "Required parameter requestParameters.body was null or undefined when calling postMitreAttacks.");
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/entities/mitre/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: MsaIdsRequestToJSON(requestParameters.body),
            },
            initOverrides
        );

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves report and observable IDs associated with the given actor and attacks
     */
    async postMitreAttacks(body: MsaIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postMitreAttacksRaw({ body: body }, initOverrides);
    }

    /**
     * Get info about actors that match provided FQL filters.
     */
    async queryIntelActorEntitiesRaw(
        requestParameters: QueryIntelActorEntitiesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<DomainActorsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.q !== undefined) {
            queryParameters["q"] = requestParameters.q;
        }

        if (requestParameters.fields) {
            queryParameters["fields"] = requestParameters.fields;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/combined/actors/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainActorsResponseFromJSON(jsonValue));
    }

    /**
     * Get info about actors that match provided FQL filters.
     */
    async queryIntelActorEntities(
        offset?: number,
        limit?: number,
        sort?: string,
        filter?: string,
        q?: string,
        fields?: Array<string>,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<DomainActorsResponse> {
        const response = await this.queryIntelActorEntitiesRaw({ offset: offset, limit: limit, sort: sort, filter: filter, q: q, fields: fields }, initOverrides);
        return await response.value();
    }

    /**
     * Get actor IDs that match provided FQL filters.
     */
    async queryIntelActorIdsRaw(requestParameters: QueryIntelActorIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MsaQueryResponse>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.q !== undefined) {
            queryParameters["q"] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/queries/actors/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaQueryResponseFromJSON(jsonValue));
    }

    /**
     * Get actor IDs that match provided FQL filters.
     */
    async queryIntelActorIds(offset?: number, limit?: number, sort?: string, filter?: string, q?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MsaQueryResponse> {
        const response = await this.queryIntelActorIdsRaw({ offset: offset, limit: limit, sort: sort, filter: filter, q: q }, initOverrides);
        return await response.value();
    }

    /**
     * Get info about indicators that match provided FQL filters.
     */
    async queryIntelIndicatorEntitiesRaw(
        requestParameters: QueryIntelIndicatorEntitiesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<DomainPublicIndicatorsV3Response>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.q !== undefined) {
            queryParameters["q"] = requestParameters.q;
        }

        if (requestParameters.includeDeleted !== undefined) {
            queryParameters["include_deleted"] = requestParameters.includeDeleted;
        }

        if (requestParameters.includeRelations !== undefined) {
            queryParameters["include_relations"] = requestParameters.includeRelations;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/combined/indicators/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainPublicIndicatorsV3ResponseFromJSON(jsonValue));
    }

    /**
     * Get info about indicators that match provided FQL filters.
     */
    async queryIntelIndicatorEntities(
        offset?: number,
        limit?: number,
        sort?: string,
        filter?: string,
        q?: string,
        includeDeleted?: boolean,
        includeRelations?: boolean,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<DomainPublicIndicatorsV3Response> {
        const response = await this.queryIntelIndicatorEntitiesRaw(
            { offset: offset, limit: limit, sort: sort, filter: filter, q: q, includeDeleted: includeDeleted, includeRelations: includeRelations },
            initOverrides
        );
        return await response.value();
    }

    /**
     * Get indicators IDs that match provided FQL filters.
     */
    async queryIntelIndicatorIdsRaw(requestParameters: QueryIntelIndicatorIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MsaQueryResponse>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.q !== undefined) {
            queryParameters["q"] = requestParameters.q;
        }

        if (requestParameters.includeDeleted !== undefined) {
            queryParameters["include_deleted"] = requestParameters.includeDeleted;
        }

        if (requestParameters.includeRelations !== undefined) {
            queryParameters["include_relations"] = requestParameters.includeRelations;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/queries/indicators/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaQueryResponseFromJSON(jsonValue));
    }

    /**
     * Get indicators IDs that match provided FQL filters.
     */
    async queryIntelIndicatorIds(
        offset?: number,
        limit?: number,
        sort?: string,
        filter?: string,
        q?: string,
        includeDeleted?: boolean,
        includeRelations?: boolean,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<MsaQueryResponse> {
        const response = await this.queryIntelIndicatorIdsRaw(
            { offset: offset, limit: limit, sort: sort, filter: filter, q: q, includeDeleted: includeDeleted, includeRelations: includeRelations },
            initOverrides
        );
        return await response.value();
    }

    /**
     * Get info about reports that match provided FQL filters.
     */
    async queryIntelReportEntitiesRaw(
        requestParameters: QueryIntelReportEntitiesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<runtime.ApiResponse<DomainNewsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.q !== undefined) {
            queryParameters["q"] = requestParameters.q;
        }

        if (requestParameters.fields) {
            queryParameters["fields"] = requestParameters.fields;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/combined/reports/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainNewsResponseFromJSON(jsonValue));
    }

    /**
     * Get info about reports that match provided FQL filters.
     */
    async queryIntelReportEntities(
        offset?: number,
        limit?: number,
        sort?: string,
        filter?: string,
        q?: string,
        fields?: Array<string>,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<DomainNewsResponse> {
        const response = await this.queryIntelReportEntitiesRaw({ offset: offset, limit: limit, sort: sort, filter: filter, q: q, fields: fields }, initOverrides);
        return await response.value();
    }

    /**
     * Get report IDs that match provided FQL filters.
     */
    async queryIntelReportIdsRaw(requestParameters: QueryIntelReportIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MsaQueryResponse>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.q !== undefined) {
            queryParameters["q"] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/queries/reports/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaQueryResponseFromJSON(jsonValue));
    }

    /**
     * Get report IDs that match provided FQL filters.
     */
    async queryIntelReportIds(offset?: number, limit?: number, sort?: string, filter?: string, q?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MsaQueryResponse> {
        const response = await this.queryIntelReportIdsRaw({ offset: offset, limit: limit, sort: sort, filter: filter, q: q }, initOverrides);
        return await response.value();
    }

    /**
     * Search for rule IDs that match provided filter criteria.
     */
    async queryIntelRuleIdsRaw(requestParameters: QueryIntelRuleIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MsaQueryResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError("type", "Required parameter requestParameters.type was null or undefined when calling queryIntelRuleIds.");
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        if (requestParameters.name) {
            queryParameters["name"] = requestParameters.name.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.type !== undefined) {
            queryParameters["type"] = requestParameters.type;
        }

        if (requestParameters.description) {
            queryParameters["description"] = requestParameters.description.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tags) {
            queryParameters["tags"] = requestParameters.tags.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.minCreatedDate !== undefined) {
            queryParameters["min_created_date"] = requestParameters.minCreatedDate;
        }

        if (requestParameters.maxCreatedDate !== undefined) {
            queryParameters["max_created_date"] = requestParameters.maxCreatedDate;
        }

        if (requestParameters.q !== undefined) {
            queryParameters["q"] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/queries/rules/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaQueryResponseFromJSON(jsonValue));
    }

    /**
     * Search for rule IDs that match provided filter criteria.
     */
    async queryIntelRuleIds(
        type: string,
        offset?: number,
        limit?: number,
        sort?: string,
        name?: Array<string>,
        description?: Array<string>,
        tags?: Array<string>,
        minCreatedDate?: number,
        maxCreatedDate?: string,
        q?: string,
        initOverrides?: RequestInit | runtime.InitOverrideFunction
    ): Promise<MsaQueryResponse> {
        const response = await this.queryIntelRuleIdsRaw(
            { type: type, offset: offset, limit: limit, sort: sort, name: name, description: description, tags: tags, minCreatedDate: minCreatedDate, maxCreatedDate: maxCreatedDate, q: q },
            initOverrides
        );
        return await response.value();
    }

    /**
     * Gets MITRE tactics and techniques for the given actor, returning concatenation of id and tactic and technique ids, example: fancy-bear_TA0011_T1071
     */
    async queryMitreAttacksRaw(requestParameters: QueryMitreAttacksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DomainQueryMitreAttacksResponse>> {
        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters["id"] = requestParameters.id;
        }

        if (requestParameters.ids) {
            queryParameters["ids"] = requestParameters.ids;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/queries/mitre/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainQueryMitreAttacksResponseFromJSON(jsonValue));
    }

    /**
     * Gets MITRE tactics and techniques for the given actor, returning concatenation of id and tactic and technique ids, example: fancy-bear_TA0011_T1071
     */
    async queryMitreAttacks(id?: string, ids?: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainQueryMitreAttacksResponse> {
        const response = await this.queryMitreAttacksRaw({ id: id, ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Get vulnerabilities IDs
     */
    async queryVulnerabilitiesRaw(requestParameters: IntelApiQueryVulnerabilitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MsaQueryResponse>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.q !== undefined) {
            queryParameters["q"] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/intel/queries/vulnerabilities/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaQueryResponseFromJSON(jsonValue));
    }

    /**
     * Get vulnerabilities IDs
     */
    async queryVulnerabilities(offset?: string, limit?: number, sort?: string, filter?: string, q?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MsaQueryResponse> {
        const response = await this.queryVulnerabilitiesRaw({ offset: offset, limit: limit, sort: sort, filter: filter, q: q }, initOverrides);
        return await response.value();
    }
}
