/* tslint:disable */
/* eslint-disable */
/**
 * CrowdStrike API Specification
 * Use this API specification as a reference for the API endpoints you can use to interact with your Falcon environment. These endpoints support authentication via OAuth2 and interact with detections and network containment. For detailed usage guides and examples, see our [documentation inside the Falcon console](https://falcon.crowdstrike.com/support/documentation).     To use the APIs described below, combine the base URL with the path shown for each API endpoint. For commercial cloud customers, your base URL is `https://api.crowdstrike.com`.    Each API endpoint requires authorization via an OAuth2 token. Your first API request should retrieve an OAuth2 token using the `oauth2/token` endpoint, such as `https://api.crowdstrike.com/oauth2/token`. For subsequent requests, include the OAuth2 token in an HTTP authorization header. Tokens expire after 30 minutes, after which you should make a new token request to continue making API requests.
 *
 * The version of the OpenAPI document: rolling
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
    ApiPolicyEntitiesResponse,
    CoreEntitiesResponse,
    DomainExternalQueryResponse,
    DomainExternalRegistryListResponse,
    DomainExternalRegistryResponse,
    ExportsExportsResponse,
    ExportsLaunchExportRequest,
    ExportsLaunchExportResponse,
    ModelsInventoryScanRequestType,
    MsaReplyMetaOnly,
    MsaspecQueryResponse,
    MsaspecResponseFields,
    RegistryassessmentExternalRegistryPatchPayload,
    RegistryassessmentExternalRegistryPayload,
} from "../models/index";
import {
    ApiPolicyEntitiesResponseFromJSON,
    ApiPolicyEntitiesResponseToJSON,
    CoreEntitiesResponseFromJSON,
    CoreEntitiesResponseToJSON,
    DomainExternalQueryResponseFromJSON,
    DomainExternalQueryResponseToJSON,
    DomainExternalRegistryListResponseFromJSON,
    DomainExternalRegistryListResponseToJSON,
    DomainExternalRegistryResponseFromJSON,
    DomainExternalRegistryResponseToJSON,
    ExportsExportsResponseFromJSON,
    ExportsExportsResponseToJSON,
    ExportsLaunchExportRequestFromJSON,
    ExportsLaunchExportRequestToJSON,
    ExportsLaunchExportResponseFromJSON,
    ExportsLaunchExportResponseToJSON,
    ModelsInventoryScanRequestTypeFromJSON,
    ModelsInventoryScanRequestTypeToJSON,
    MsaReplyMetaOnlyFromJSON,
    MsaReplyMetaOnlyToJSON,
    MsaspecQueryResponseFromJSON,
    MsaspecQueryResponseToJSON,
    MsaspecResponseFieldsFromJSON,
    MsaspecResponseFieldsToJSON,
    RegistryassessmentExternalRegistryPatchPayloadFromJSON,
    RegistryassessmentExternalRegistryPatchPayloadToJSON,
    RegistryassessmentExternalRegistryPayloadFromJSON,
    RegistryassessmentExternalRegistryPayloadToJSON,
} from "../models/index";

export interface FalconContainerImageApiCreateRegistryEntitiesRequest {
    body: RegistryassessmentExternalRegistryPayload;
}

export interface FalconContainerImageApiDeleteRegistryEntitiesRequest {
    ids: string;
}

export interface FalconContainerImageApiDownloadExportFileRequest {
    id: string;
}

export interface FalconContainerImageApiGetReportByReferenceRequest {
    registry?: string;
    repository?: string;
    tag?: string;
    imageId?: string;
    digest?: string;
    reportFormat?: string;
}

export interface FalconContainerImageApiGetReportByScanIDRequest {
    uuid: string;
    reportFormat?: string;
}

export interface FalconContainerImageApiLaunchExportJobRequest {
    body: ExportsLaunchExportRequest;
}

export interface FalconContainerImageApiPolicyChecksRequest {
    repository: string;
    tag: string;
    registry?: string;
}

export interface FalconContainerImageApiPostImageScanInventoryRequest {
    body: ModelsInventoryScanRequestType;
}

export interface FalconContainerImageApiQueryExportJobsRequest {
    filter?: string;
}

export interface FalconContainerImageApiReadExportJobsRequest {
    ids: Array<string>;
}

export interface FalconContainerImageApiReadRegistryEntitiesRequest {
    limit?: number;
    offset?: number;
    sort?: string;
}

export interface FalconContainerImageApiReadRegistryEntitiesByUUIDRequest {
    ids: string;
}

export interface FalconContainerImageApiUpdateRegistryEntitiesRequest {
    id: string;
    body: RegistryassessmentExternalRegistryPatchPayload;
}

/**
 *
 */
export class FalconContainerImageApi extends runtime.BaseAPI {
    /**
     * Create a registry entity using the provided details
     */
    async createRegistryEntitiesRaw(
        requestParameters: FalconContainerImageApiCreateRegistryEntitiesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainExternalRegistryResponse>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling createRegistryEntities().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falcon-container-image:write"]);
        }

        const response = await this.request(
            {
                path: `/container-security/entities/registries/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: RegistryassessmentExternalRegistryPayloadToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainExternalRegistryResponseFromJSON(jsonValue));
    }

    /**
     * Create a registry entity using the provided details
     */
    async createRegistryEntities(body: RegistryassessmentExternalRegistryPayload, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainExternalRegistryResponse> {
        const response = await this.createRegistryEntitiesRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Delete the registry entity identified by the entity UUID
     */
    async deleteRegistryEntitiesRaw(
        requestParameters: FalconContainerImageApiDeleteRegistryEntitiesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainExternalRegistryListResponse>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling deleteRegistryEntities().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falcon-container-image:write"]);
        }

        const response = await this.request(
            {
                path: `/container-security/entities/registries/v1`,
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainExternalRegistryListResponseFromJSON(jsonValue));
    }

    /**
     * Delete the registry entity identified by the entity UUID
     */
    async deleteRegistryEntities(ids: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainExternalRegistryListResponse> {
        const response = await this.deleteRegistryEntitiesRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Download an export file
     */
    async downloadExportFileRaw(
        requestParameters: FalconContainerImageApiDownloadExportFileRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters["id"] == null) {
            throw new runtime.RequiredError("id", 'Required parameter "id" was null or undefined when calling downloadExportFile().');
        }

        const queryParameters: any = {};

        if (requestParameters["id"] != null) {
            queryParameters["id"] = requestParameters["id"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falcon-container-image:read"]);
        }

        const response = await this.request(
            {
                path: `/container-security/entities/exports/files/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Download an export file
     */
    async downloadExportFile(id: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.downloadExportFileRaw({ id: id }, initOverrides);
        return await response.value();
    }

    /**
     * Get image assessment scan report by image reference (v2)
     */
    async getReportByReferenceRaw(
        requestParameters: FalconContainerImageApiGetReportByReferenceRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<CoreEntitiesResponse>> {
        const queryParameters: any = {};

        if (requestParameters["registry"] != null) {
            queryParameters["registry"] = requestParameters["registry"];
        }

        if (requestParameters["repository"] != null) {
            queryParameters["repository"] = requestParameters["repository"];
        }

        if (requestParameters["tag"] != null) {
            queryParameters["tag"] = requestParameters["tag"];
        }

        if (requestParameters["imageId"] != null) {
            queryParameters["image_id"] = requestParameters["imageId"];
        }

        if (requestParameters["digest"] != null) {
            queryParameters["digest"] = requestParameters["digest"];
        }

        if (requestParameters["reportFormat"] != null) {
            queryParameters["report_format"] = requestParameters["reportFormat"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falcon-container-image:read"]);
        }

        const response = await this.request(
            {
                path: `/image-assessment/entities/reports/v2`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => CoreEntitiesResponseFromJSON(jsonValue));
    }

    /**
     * Get image assessment scan report by image reference (v2)
     */
    async getReportByReference(
        registry?: string,
        repository?: string,
        tag?: string,
        imageId?: string,
        digest?: string,
        reportFormat?: string,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<CoreEntitiesResponse> {
        const response = await this.getReportByReferenceRaw({ registry: registry, repository: repository, tag: tag, imageId: imageId, digest: digest, reportFormat: reportFormat }, initOverrides);
        return await response.value();
    }

    /**
     * Get image assessment scan report by scan UUID (v2)
     */
    async getReportByScanIDRaw(
        requestParameters: FalconContainerImageApiGetReportByScanIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<CoreEntitiesResponse>> {
        if (requestParameters["uuid"] == null) {
            throw new runtime.RequiredError("uuid", 'Required parameter "uuid" was null or undefined when calling getReportByScanID().');
        }

        const queryParameters: any = {};

        if (requestParameters["reportFormat"] != null) {
            queryParameters["report_format"] = requestParameters["reportFormat"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falcon-container-image:read"]);
        }

        const response = await this.request(
            {
                path: `/image-assessment/entities/reports/v2/{uuid}`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters["uuid"]))),
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => CoreEntitiesResponseFromJSON(jsonValue));
    }

    /**
     * Get image assessment scan report by scan UUID (v2)
     */
    async getReportByScanID(uuid: string, reportFormat?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CoreEntitiesResponse> {
        const response = await this.getReportByScanIDRaw({ uuid: uuid, reportFormat: reportFormat }, initOverrides);
        return await response.value();
    }

    /**
     * Get headers for POST request for image scan inventory
     */
    async headImageScanInventoryRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falcon-container-cli:read"]);
        }

        const response = await this.request(
            {
                path: `/image-assessment/entities/image-inventory/v1`,
                method: "HEAD",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get headers for POST request for image scan inventory
     */
    async headImageScanInventory(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.headImageScanInventoryRaw(initOverrides);
    }

    /**
     * Launch an export job of a Container Security resource. Maximum of 1 job in progress per resource
     */
    async launchExportJobRaw(
        requestParameters: FalconContainerImageApiLaunchExportJobRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ExportsLaunchExportResponse>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling launchExportJob().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falcon-container-image:read"]);
        }

        const response = await this.request(
            {
                path: `/container-security/entities/exports/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: ExportsLaunchExportRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportsLaunchExportResponseFromJSON(jsonValue));
    }

    /**
     * Launch an export job of a Container Security resource. Maximum of 1 job in progress per resource
     */
    async launchExportJob(body: ExportsLaunchExportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportsLaunchExportResponse> {
        const response = await this.launchExportJobRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Check image prevention policies
     */
    async policyChecksRaw(
        requestParameters: FalconContainerImageApiPolicyChecksRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiPolicyEntitiesResponse>> {
        if (requestParameters["repository"] == null) {
            throw new runtime.RequiredError("repository", 'Required parameter "repository" was null or undefined when calling policyChecks().');
        }

        if (requestParameters["tag"] == null) {
            throw new runtime.RequiredError("tag", 'Required parameter "tag" was null or undefined when calling policyChecks().');
        }

        const queryParameters: any = {};

        if (requestParameters["registry"] != null) {
            queryParameters["registry"] = requestParameters["registry"];
        }

        if (requestParameters["repository"] != null) {
            queryParameters["repository"] = requestParameters["repository"];
        }

        if (requestParameters["tag"] != null) {
            queryParameters["tag"] = requestParameters["tag"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falcon-container-image:read"]);
        }

        const response = await this.request(
            {
                path: `/image-assessment/entities/policy-checks/v2`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiPolicyEntitiesResponseFromJSON(jsonValue));
    }

    /**
     * Check image prevention policies
     */
    async policyChecks(repository: string, tag: string, registry?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiPolicyEntitiesResponse> {
        const response = await this.policyChecksRaw({ repository: repository, tag: tag, registry: registry }, initOverrides);
        return await response.value();
    }

    /**
     * Post image scan inventory
     */
    async postImageScanInventoryRaw(
        requestParameters: FalconContainerImageApiPostImageScanInventoryRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling postImageScanInventory().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falcon-container-cli:write"]);
        }

        const response = await this.request(
            {
                path: `/image-assessment/entities/image-inventory/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: ModelsInventoryScanRequestTypeToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Post image scan inventory
     */
    async postImageScanInventory(body: ModelsInventoryScanRequestType, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postImageScanInventoryRaw({ body: body }, initOverrides);
    }

    /**
     * Query export jobs entities
     */
    async queryExportJobsRaw(
        requestParameters: FalconContainerImageApiQueryExportJobsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<MsaspecQueryResponse>> {
        const queryParameters: any = {};

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falcon-container-image:read"]);
        }

        const response = await this.request(
            {
                path: `/container-security/queries/exports/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaspecQueryResponseFromJSON(jsonValue));
    }

    /**
     * Query export jobs entities
     */
    async queryExportJobs(filter?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MsaspecQueryResponse> {
        const response = await this.queryExportJobsRaw({ filter: filter }, initOverrides);
        return await response.value();
    }

    /**
     * Read export jobs entities
     */
    async readExportJobsRaw(
        requestParameters: FalconContainerImageApiReadExportJobsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ExportsExportsResponse>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling readExportJobs().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falcon-container-image:read"]);
        }

        const response = await this.request(
            {
                path: `/container-security/entities/exports/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportsExportsResponseFromJSON(jsonValue));
    }

    /**
     * Read export jobs entities
     */
    async readExportJobs(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportsExportsResponse> {
        const response = await this.readExportJobsRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of registry entities identified by the customer id. Maximum page size: 5,000
     */
    async readRegistryEntitiesRaw(
        requestParameters: FalconContainerImageApiReadRegistryEntitiesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainExternalQueryResponse>> {
        const queryParameters: any = {};

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falcon-container-image:read"]);
        }

        const response = await this.request(
            {
                path: `/container-security/queries/registries/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainExternalQueryResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves a list of registry entities identified by the customer id. Maximum page size: 5,000
     */
    async readRegistryEntities(limit?: number, offset?: number, sort?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainExternalQueryResponse> {
        const response = await this.readRegistryEntitiesRaw({ limit: limit, offset: offset, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of registry entities by the provided UUIDs. Maximum page size: 100
     */
    async readRegistryEntitiesByUUIDRaw(
        requestParameters: FalconContainerImageApiReadRegistryEntitiesByUUIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainExternalRegistryListResponse>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling readRegistryEntitiesByUUID().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falcon-container-image:read"]);
        }

        const response = await this.request(
            {
                path: `/container-security/entities/registries/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainExternalRegistryListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves a list of registry entities by the provided UUIDs. Maximum page size: 100
     */
    async readRegistryEntitiesByUUID(ids: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainExternalRegistryListResponse> {
        const response = await this.readRegistryEntitiesByUUIDRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Update the registry entity, as identified by the entity UUID, using the provided details
     */
    async updateRegistryEntitiesRaw(
        requestParameters: FalconContainerImageApiUpdateRegistryEntitiesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainExternalRegistryResponse>> {
        if (requestParameters["id"] == null) {
            throw new runtime.RequiredError("id", 'Required parameter "id" was null or undefined when calling updateRegistryEntities().');
        }

        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling updateRegistryEntities().');
        }

        const queryParameters: any = {};

        if (requestParameters["id"] != null) {
            queryParameters["id"] = requestParameters["id"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falcon-container-image:write"]);
        }

        const response = await this.request(
            {
                path: `/container-security/entities/registries/v1`,
                method: "PATCH",
                headers: headerParameters,
                query: queryParameters,
                body: RegistryassessmentExternalRegistryPatchPayloadToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainExternalRegistryResponseFromJSON(jsonValue));
    }

    /**
     * Update the registry entity, as identified by the entity UUID, using the provided details
     */
    async updateRegistryEntities(
        id: string,
        body: RegistryassessmentExternalRegistryPatchPayload,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DomainExternalRegistryResponse> {
        const response = await this.updateRegistryEntitiesRaw({ id: id, body: body }, initOverrides);
        return await response.value();
    }
}
