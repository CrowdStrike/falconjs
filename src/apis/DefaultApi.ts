/* tslint:disable */
/* eslint-disable */
/**
 * CrowdStrike API Specification
 * Use this API specification as a reference for the API endpoints you can use to interact with your Falcon environment. These endpoints support authentication via OAuth2 and interact with detections and network containment. For detailed usage guides and examples, see our [documentation inside the Falcon console](https://falcon.crowdstrike.com/support/documentation).     To use the APIs described below, combine the base URL with the path shown for each API endpoint. For commercial cloud customers, your base URL is `https://api.crowdstrike.com`.    Each API endpoint requires authorization via an OAuth2 token. Your first API request should retrieve an OAuth2 token using the `oauth2/token` endpoint, such as `https://api.crowdstrike.com/oauth2/token`. For subsequent requests, include the OAuth2 token in an HTTP authorization header. Tokens expire after 30 minutes, after which you should make a new token request to continue making API requests.
 *
 * The version of the OpenAPI document: rolling
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
    DomainAggregateCollectionCountsByResponseV1,
    DomainDeployAgentsRequest,
    DomainEntitiesCollectionsResponseV1,
    DomainEntitiesCollectorsResponseV1,
    DomainEntitiesConfigurationsResponseV1,
    DomainEntitiesTemplatesResponseV1,
    DomainNewCollectionsRequest,
    DomainQueriesResponseV1,
    DomainResponseV1,
    DomainSPAPICombinedInstalledPatchesResponse,
    DomainSaveConfigRequest,
    DomainShutDownAgentsRequest,
    DomainValidateCollectionRequest,
    MsaQueryResponse,
    MsaReplyMetaOnly,
    MsaspecResponseFields,
    PluginsonpremapiOnPremConfigureRequest,
    PluginsonpremapiOnPremConfigureResponse,
    PluginsonpremapiOnPremGetHostConfigsResponse,
} from "../models/index";
import {
    DomainAggregateCollectionCountsByResponseV1FromJSON,
    DomainAggregateCollectionCountsByResponseV1ToJSON,
    DomainDeployAgentsRequestFromJSON,
    DomainDeployAgentsRequestToJSON,
    DomainEntitiesCollectionsResponseV1FromJSON,
    DomainEntitiesCollectionsResponseV1ToJSON,
    DomainEntitiesCollectorsResponseV1FromJSON,
    DomainEntitiesCollectorsResponseV1ToJSON,
    DomainEntitiesConfigurationsResponseV1FromJSON,
    DomainEntitiesConfigurationsResponseV1ToJSON,
    DomainEntitiesTemplatesResponseV1FromJSON,
    DomainEntitiesTemplatesResponseV1ToJSON,
    DomainNewCollectionsRequestFromJSON,
    DomainNewCollectionsRequestToJSON,
    DomainQueriesResponseV1FromJSON,
    DomainQueriesResponseV1ToJSON,
    DomainResponseV1FromJSON,
    DomainResponseV1ToJSON,
    DomainSPAPICombinedInstalledPatchesResponseFromJSON,
    DomainSPAPICombinedInstalledPatchesResponseToJSON,
    DomainSaveConfigRequestFromJSON,
    DomainSaveConfigRequestToJSON,
    DomainShutDownAgentsRequestFromJSON,
    DomainShutDownAgentsRequestToJSON,
    DomainValidateCollectionRequestFromJSON,
    DomainValidateCollectionRequestToJSON,
    MsaQueryResponseFromJSON,
    MsaQueryResponseToJSON,
    MsaReplyMetaOnlyFromJSON,
    MsaReplyMetaOnlyToJSON,
    MsaspecResponseFieldsFromJSON,
    MsaspecResponseFieldsToJSON,
    PluginsonpremapiOnPremConfigureRequestFromJSON,
    PluginsonpremapiOnPremConfigureRequestToJSON,
    PluginsonpremapiOnPremConfigureResponseFromJSON,
    PluginsonpremapiOnPremConfigureResponseToJSON,
    PluginsonpremapiOnPremGetHostConfigsResponseFromJSON,
    PluginsonpremapiOnPremGetHostConfigsResponseToJSON,
} from "../models/index";

export interface DefaultApiCombinedQueryInstalledPatchesRequest {
    after?: string;
    limit?: number;
    filter?: string;
    sort?: string;
}

export interface DefaultApiDeleteCollectionsV1Request {
    ids?: Array<string>;
}

export interface DefaultApiDeleteConfigsV1Request {
    ids: Array<string>;
}

export interface DefaultApiGetCollectionCountsByV1Request {
    filter?: string;
    limit?: string;
    offset?: string;
    sort?: GetCollectionCountsByV1SortEnum;
}

export interface DefaultApiGetCollectionsV1Request {
    ids?: Array<string>;
    platform?: GetCollectionsV1PlatformEnum;
    aids?: Array<string>;
    ffcids?: Array<string>;
    states?: Array<string>;
    sort?: GetCollectionsV1SortEnum;
}

export interface DefaultApiGetCollectorsV1Request {
    ids?: Array<string>;
    platform?: GetCollectorsV1PlatformEnum;
    sort?: GetCollectorsV1SortEnum;
}

export interface DefaultApiGetCombinedCollectionsV1Request {
    ids?: Array<string>;
    filter?: string;
    limit?: string;
    offset?: string;
    sort?: GetCombinedCollectionsV1SortEnum;
}

export interface DefaultApiGetCombinedCollectorsV1Request {
    ids?: Array<string>;
    filter?: string;
    limit?: string;
    offset?: string;
    sort?: GetCombinedCollectorsV1SortEnum;
}

export interface DefaultApiGetCombinedConfigsV1Request {
    ids?: Array<string>;
    filter?: string;
    limit?: string;
    offset?: string;
    sort?: GetCombinedConfigsV1SortEnum;
}

export interface DefaultApiGetCombinedTemplatesV1Request {
    ids?: Array<string>;
    filter?: string;
    limit?: string;
    offset?: string;
    sort?: GetCombinedTemplatesV1SortEnum;
}

export interface DefaultApiGetConfigDownloadV1Request {
    id: string;
    collectionTag?: string;
    selfDestruct?: boolean;
}

export interface DefaultApiGetConfigsV1Request {
    ids: Array<string>;
}

export interface DefaultApiGetTemplatesV1Request {
    ids: Array<string>;
}

export interface DefaultApiPostCollectionsV1Request {
    body: DomainNewCollectionsRequest;
}

export interface DefaultApiPostCollectorsV1Request {
    body: DomainShutDownAgentsRequest;
}

export interface DefaultApiPostConfigsV1Request {
    body: DomainSaveConfigRequest;
}

export interface DefaultApiPostDeployV1Request {
    body: DomainDeployAgentsRequest;
}

export interface DefaultApiPutCollectionsV1Request {
    body: DomainNewCollectionsRequest;
}

export interface DefaultApiPutConfigsV1Request {
    body: DomainSaveConfigRequest;
}

export interface DefaultApiSearchCollectionsV1Request {
    platform?: SearchCollectionsV1PlatformEnum;
    states?: Array<string>;
    aids?: Array<string>;
    ffcids?: Array<string>;
    filter?: string;
    limit?: string;
    offset?: string;
    sort?: SearchCollectionsV1SortEnum;
}

export interface DefaultApiSearchCollectorsV1Request {
    platform?: SearchCollectorsV1PlatformEnum;
    filter?: string;
    limit?: string;
    offset?: string;
    sort?: SearchCollectorsV1SortEnum;
}

export interface DefaultApiSearchConfigsV1Request {
    filter?: string;
    limit?: string;
    offset?: string;
    sort?: SearchConfigsV1SortEnum;
}

export interface DefaultApiSearchTemplatesV1Request {
    filter?: string;
    limit?: string;
    offset?: string;
    sort?: SearchTemplatesV1SortEnum;
}

export interface DefaultApiV1HostConfigsPostRequest {
    body: PluginsonpremapiOnPremConfigureRequest;
}

export interface DefaultApiV1StatusGetRequest {
    ids: Array<string>;
}

export interface DefaultApiValidateCollectionV1Request {
    body: DomainValidateCollectionRequest;
}

export interface DefaultApiValidateConfigV1Request {
    body: DomainSaveConfigRequest;
}

/**
 *
 */
export class DefaultApi extends runtime.BaseAPI {
    /**
     * Get installed patches information for hosts
     */
    async combinedQueryInstalledPatchesRaw(
        requestParameters: DefaultApiCombinedQueryInstalledPatchesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainSPAPICombinedInstalledPatchesResponse>> {
        const queryParameters: any = {};

        if (requestParameters["after"] != null) {
            queryParameters["after"] = requestParameters["after"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["spotlight-vulnerabilities:read"]);
        }

        const response = await this.request(
            {
                path: `/spotlight/combined/installed-patches/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainSPAPICombinedInstalledPatchesResponseFromJSON(jsonValue));
    }

    /**
     * Get installed patches information for hosts
     */
    async combinedQueryInstalledPatches(
        after?: string,
        limit?: number,
        filter?: string,
        sort?: string,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DomainSPAPICombinedInstalledPatchesResponse> {
        const response = await this.combinedQueryInstalledPatchesRaw({ after: after, limit: limit, filter: filter, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Cancel Collections
     */
    async deleteCollectionsV1Raw(
        requestParameters: DefaultApiDeleteCollectionsV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainEntitiesCollectionsResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:write"]);
        }

        const response = await this.request(
            {
                path: `/forensics/entities/collections/v1`,
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainEntitiesCollectionsResponseV1FromJSON(jsonValue));
    }

    /**
     * Cancel Collections
     */
    async deleteCollectionsV1(ids?: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainEntitiesCollectionsResponseV1> {
        const response = await this.deleteCollectionsV1Raw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Retires a custom configuration
     */
    async deleteConfigsV1Raw(
        requestParameters: DefaultApiDeleteConfigsV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainEntitiesConfigurationsResponseV1>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling deleteConfigsV1().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:write"]);
        }

        const response = await this.request(
            {
                path: `/forensics/entities/configurations/v1`,
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainEntitiesConfigurationsResponseV1FromJSON(jsonValue));
    }

    /**
     * Retires a custom configuration
     */
    async deleteConfigsV1(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainEntitiesConfigurationsResponseV1> {
        const response = await this.deleteConfigsV1Raw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     */
    async falconCompleteDashboardsQueriesDetectsV1GetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MsaQueryResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request(
            {
                path: `/falcon-complete-dashboards/queries/detects/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaQueryResponseFromJSON(jsonValue));
    }

    /**
     */
    async falconCompleteDashboardsQueriesDetectsV1Get(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MsaQueryResponse> {
        const response = await this.falconCompleteDashboardsQueriesDetectsV1GetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get Collection counts by field names: collection_tag and state
     */
    async getCollectionCountsByV1Raw(
        requestParameters: DefaultApiGetCollectionCountsByV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainAggregateCollectionCountsByResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:read"]);
        }

        const response = await this.request(
            {
                path: `/forensics/aggregate/collection-counts-by/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainAggregateCollectionCountsByResponseV1FromJSON(jsonValue));
    }

    /**
     * Get Collection counts by field names: collection_tag and state
     */
    async getCollectionCountsByV1(
        filter?: string,
        limit?: string,
        offset?: string,
        sort?: GetCollectionCountsByV1SortEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DomainAggregateCollectionCountsByResponseV1> {
        const response = await this.getCollectionCountsByV1Raw({ filter: filter, limit: limit, offset: offset, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Get Collections with given IDs, Platform, Agent/Collector IDs, States
     */
    async getCollectionsV1Raw(
        requestParameters: DefaultApiGetCollectionsV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainEntitiesCollectionsResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters["platform"] != null) {
            queryParameters["platform"] = requestParameters["platform"];
        }

        if (requestParameters["aids"] != null) {
            queryParameters["aids"] = requestParameters["aids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters["ffcids"] != null) {
            queryParameters["ffcids"] = requestParameters["ffcids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters["states"] != null) {
            queryParameters["states"] = requestParameters["states"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:read"]);
        }

        const response = await this.request(
            {
                path: `/forensics/entities/collections/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainEntitiesCollectionsResponseV1FromJSON(jsonValue));
    }

    /**
     * Get Collections with given IDs, Platform, Agent/Collector IDs, States
     */
    async getCollectionsV1(
        ids?: Array<string>,
        platform?: GetCollectionsV1PlatformEnum,
        aids?: Array<string>,
        ffcids?: Array<string>,
        states?: Array<string>,
        sort?: GetCollectionsV1SortEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DomainEntitiesCollectionsResponseV1> {
        const response = await this.getCollectionsV1Raw({ ids: ids, platform: platform, aids: aids, ffcids: ffcids, states: states, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Get collectors
     */
    async getCollectorsV1Raw(
        requestParameters: DefaultApiGetCollectorsV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainEntitiesCollectorsResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters["platform"] != null) {
            queryParameters["platform"] = requestParameters["platform"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:read"]);
        }

        const response = await this.request(
            {
                path: `/forensics/entities/collectors/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainEntitiesCollectorsResponseV1FromJSON(jsonValue));
    }

    /**
     * Get collectors
     */
    async getCollectorsV1(
        ids?: Array<string>,
        platform?: GetCollectorsV1PlatformEnum,
        sort?: GetCollectorsV1SortEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DomainEntitiesCollectorsResponseV1> {
        const response = await this.getCollectorsV1Raw({ ids: ids, platform: platform, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Get Collections with given IDs, Platform, Agent/Collector IDs, States
     */
    async getCombinedCollectionsV1Raw(
        requestParameters: DefaultApiGetCombinedCollectionsV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainEntitiesCollectionsResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:read"]);
        }

        const response = await this.request(
            {
                path: `/forensics/combined/collections/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainEntitiesCollectionsResponseV1FromJSON(jsonValue));
    }

    /**
     * Get Collections with given IDs, Platform, Agent/Collector IDs, States
     */
    async getCombinedCollectionsV1(
        ids?: Array<string>,
        filter?: string,
        limit?: string,
        offset?: string,
        sort?: GetCombinedCollectionsV1SortEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DomainEntitiesCollectionsResponseV1> {
        const response = await this.getCombinedCollectionsV1Raw({ ids: ids, filter: filter, limit: limit, offset: offset, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Get collectors for the given Customer ID
     */
    async getCombinedCollectorsV1Raw(
        requestParameters: DefaultApiGetCombinedCollectorsV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainEntitiesCollectorsResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:read"]);
        }

        const response = await this.request(
            {
                path: `/forensics/combined/collectors/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainEntitiesCollectorsResponseV1FromJSON(jsonValue));
    }

    /**
     * Get collectors for the given Customer ID
     */
    async getCombinedCollectorsV1(
        ids?: Array<string>,
        filter?: string,
        limit?: string,
        offset?: string,
        sort?: GetCombinedCollectorsV1SortEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DomainEntitiesCollectorsResponseV1> {
        const response = await this.getCombinedCollectorsV1Raw({ ids: ids, filter: filter, limit: limit, offset: offset, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Get Configurations for the given Customer ID
     */
    async getCombinedConfigsV1Raw(
        requestParameters: DefaultApiGetCombinedConfigsV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainEntitiesConfigurationsResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:read"]);
        }

        const response = await this.request(
            {
                path: `/forensics/combined/configurations/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainEntitiesConfigurationsResponseV1FromJSON(jsonValue));
    }

    /**
     * Get Configurations for the given Customer ID
     */
    async getCombinedConfigsV1(
        ids?: Array<string>,
        filter?: string,
        limit?: string,
        offset?: string,
        sort?: GetCombinedConfigsV1SortEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DomainEntitiesConfigurationsResponseV1> {
        const response = await this.getCombinedConfigsV1Raw({ ids: ids, filter: filter, limit: limit, offset: offset, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Get Templates with the given IDs
     */
    async getCombinedTemplatesV1Raw(
        requestParameters: DefaultApiGetCombinedTemplatesV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainEntitiesTemplatesResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:read"]);
        }

        const response = await this.request(
            {
                path: `/forensics/combined/templates/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainEntitiesTemplatesResponseV1FromJSON(jsonValue));
    }

    /**
     * Get Templates with the given IDs
     */
    async getCombinedTemplatesV1(
        ids?: Array<string>,
        filter?: string,
        limit?: string,
        offset?: string,
        sort?: GetCombinedTemplatesV1SortEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DomainEntitiesTemplatesResponseV1> {
        const response = await this.getCombinedTemplatesV1Raw({ ids: ids, filter: filter, limit: limit, offset: offset, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Download offline Configuration file using ID
     */
    async getConfigDownloadV1Raw(requestParameters: DefaultApiGetConfigDownloadV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        if (requestParameters["id"] == null) {
            throw new runtime.RequiredError("id", 'Required parameter "id" was null or undefined when calling getConfigDownloadV1().');
        }

        const queryParameters: any = {};

        if (requestParameters["id"] != null) {
            queryParameters["id"] = requestParameters["id"];
        }

        if (requestParameters["collectionTag"] != null) {
            queryParameters["collection_tag"] = requestParameters["collectionTag"];
        }

        if (requestParameters["selfDestruct"] != null) {
            queryParameters["self_destruct"] = requestParameters["selfDestruct"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:read"]);
        }

        const response = await this.request(
            {
                path: `/forensics/entities/configuration-download/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Download offline Configuration file using ID
     */
    async getConfigDownloadV1(id: string, collectionTag?: string, selfDestruct?: boolean, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.getConfigDownloadV1Raw({ id: id, collectionTag: collectionTag, selfDestruct: selfDestruct }, initOverrides);
        return await response.value();
    }

    /**
     * Get Configurations with the given IDs
     */
    async getConfigsV1Raw(
        requestParameters: DefaultApiGetConfigsV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainEntitiesConfigurationsResponseV1>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling getConfigsV1().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:read"]);
        }

        const response = await this.request(
            {
                path: `/forensics/entities/configurations/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainEntitiesConfigurationsResponseV1FromJSON(jsonValue));
    }

    /**
     * Get Configurations with the given IDs
     */
    async getConfigsV1(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainEntitiesConfigurationsResponseV1> {
        const response = await this.getConfigsV1Raw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Get Templates with the given IDs
     */
    async getTemplatesV1Raw(
        requestParameters: DefaultApiGetTemplatesV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainEntitiesTemplatesResponseV1>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling getTemplatesV1().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:read"]);
        }

        const response = await this.request(
            {
                path: `/forensics/entities/templates/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainEntitiesTemplatesResponseV1FromJSON(jsonValue));
    }

    /**
     * Get Templates with the given IDs
     */
    async getTemplatesV1(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainEntitiesTemplatesResponseV1> {
        const response = await this.getTemplatesV1Raw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Create Collections
     */
    async postCollectionsV1Raw(
        requestParameters: DefaultApiPostCollectionsV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainEntitiesCollectionsResponseV1>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling postCollectionsV1().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:write"]);
        }

        const response = await this.request(
            {
                path: `/forensics/entities/collections/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: DomainNewCollectionsRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainEntitiesCollectionsResponseV1FromJSON(jsonValue));
    }

    /**
     * Create Collections
     */
    async postCollectionsV1(body: DomainNewCollectionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainEntitiesCollectionsResponseV1> {
        const response = await this.postCollectionsV1Raw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * shutdown collectors with self_destruct option
     */
    async postCollectorsV1Raw(
        requestParameters: DefaultApiPostCollectorsV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainEntitiesCollectorsResponseV1>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling postCollectorsV1().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:write"]);
        }

        const response = await this.request(
            {
                path: `/forensics/entities/collectors-shutdown/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: DomainShutDownAgentsRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainEntitiesCollectorsResponseV1FromJSON(jsonValue));
    }

    /**
     * shutdown collectors with self_destruct option
     */
    async postCollectorsV1(body: DomainShutDownAgentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainEntitiesCollectorsResponseV1> {
        const response = await this.postCollectorsV1Raw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new custom configuration
     */
    async postConfigsV1Raw(
        requestParameters: DefaultApiPostConfigsV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainEntitiesConfigurationsResponseV1>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling postConfigsV1().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:write"]);
        }

        const response = await this.request(
            {
                path: `/forensics/entities/configurations/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: DomainSaveConfigRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainEntitiesConfigurationsResponseV1FromJSON(jsonValue));
    }

    /**
     * Creates a new custom configuration
     */
    async postConfigsV1(body: DomainSaveConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainEntitiesConfigurationsResponseV1> {
        const response = await this.postConfigsV1Raw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * deploy collector to managed endpoints
     */
    async postDeployV1Raw(
        requestParameters: DefaultApiPostDeployV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainEntitiesCollectorsResponseV1>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling postDeployV1().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:write"]);
        }

        const response = await this.request(
            {
                path: `/forensics/entities/collectors-deploy/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: DomainDeployAgentsRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainEntitiesCollectorsResponseV1FromJSON(jsonValue));
    }

    /**
     * deploy collector to managed endpoints
     */
    async postDeployV1(body: DomainDeployAgentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainEntitiesCollectorsResponseV1> {
        const response = await this.postDeployV1Raw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * - request graphql query
     */
    async postGraphqlQueryMixin0Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: any }>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request(
            {
                path: `/cloud-data-protection/entities/schedules/graphql/v2`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * - request graphql query
     */
    async postGraphqlQueryMixin0(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: any }> {
        const response = await this.postGraphqlQueryMixin0Raw(initOverrides);
        return await response.value();
    }

    /**
     * Update Collections
     */
    async putCollectionsV1Raw(
        requestParameters: DefaultApiPutCollectionsV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainEntitiesCollectionsResponseV1>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling putCollectionsV1().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:write"]);
        }

        const response = await this.request(
            {
                path: `/forensics/entities/collections/v1`,
                method: "PUT",
                headers: headerParameters,
                query: queryParameters,
                body: DomainNewCollectionsRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainEntitiesCollectionsResponseV1FromJSON(jsonValue));
    }

    /**
     * Update Collections
     */
    async putCollectionsV1(body: DomainNewCollectionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainEntitiesCollectionsResponseV1> {
        const response = await this.putCollectionsV1Raw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Creates or replaces an existing custom configuration
     */
    async putConfigsV1Raw(
        requestParameters: DefaultApiPutConfigsV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainEntitiesConfigurationsResponseV1>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling putConfigsV1().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:write"]);
        }

        const response = await this.request(
            {
                path: `/forensics/entities/configurations/v1`,
                method: "PUT",
                headers: headerParameters,
                query: queryParameters,
                body: DomainSaveConfigRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainEntitiesConfigurationsResponseV1FromJSON(jsonValue));
    }

    /**
     * Creates or replaces an existing custom configuration
     */
    async putConfigsV1(body: DomainSaveConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainEntitiesConfigurationsResponseV1> {
        const response = await this.putConfigsV1Raw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Search Collections for the given Customer ID and/or Platform in states
     */
    async searchCollectionsV1Raw(
        requestParameters: DefaultApiSearchCollectionsV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainQueriesResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["platform"] != null) {
            queryParameters["platform"] = requestParameters["platform"];
        }

        if (requestParameters["states"] != null) {
            queryParameters["states"] = requestParameters["states"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters["aids"] != null) {
            queryParameters["aids"] = requestParameters["aids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters["ffcids"] != null) {
            queryParameters["ffcids"] = requestParameters["ffcids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:read"]);
        }

        const response = await this.request(
            {
                path: `/forensics/queries/collections/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainQueriesResponseV1FromJSON(jsonValue));
    }

    /**
     * Search Collections for the given Customer ID and/or Platform in states
     */
    async searchCollectionsV1(
        platform?: SearchCollectionsV1PlatformEnum,
        states?: Array<string>,
        aids?: Array<string>,
        ffcids?: Array<string>,
        filter?: string,
        limit?: string,
        offset?: string,
        sort?: SearchCollectionsV1SortEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DomainQueriesResponseV1> {
        const response = await this.searchCollectionsV1Raw({ platform: platform, states: states, aids: aids, ffcids: ffcids, filter: filter, limit: limit, offset: offset, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Search Collectors for the given Customer ID and Platform
     */
    async searchCollectorsV1Raw(
        requestParameters: DefaultApiSearchCollectorsV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainQueriesResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["platform"] != null) {
            queryParameters["platform"] = requestParameters["platform"];
        }

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:read"]);
        }

        const response = await this.request(
            {
                path: `/forensics/queries/collectors/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainQueriesResponseV1FromJSON(jsonValue));
    }

    /**
     * Search Collectors for the given Customer ID and Platform
     */
    async searchCollectorsV1(
        platform?: SearchCollectorsV1PlatformEnum,
        filter?: string,
        limit?: string,
        offset?: string,
        sort?: SearchCollectorsV1SortEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DomainQueriesResponseV1> {
        const response = await this.searchCollectorsV1Raw({ platform: platform, filter: filter, limit: limit, offset: offset, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Search Configurations for the given Customer ID
     */
    async searchConfigsV1Raw(requestParameters: DefaultApiSearchConfigsV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DomainQueriesResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:read"]);
        }

        const response = await this.request(
            {
                path: `/forensics/queries/configurations/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainQueriesResponseV1FromJSON(jsonValue));
    }

    /**
     * Search Configurations for the given Customer ID
     */
    async searchConfigsV1(
        filter?: string,
        limit?: string,
        offset?: string,
        sort?: SearchConfigsV1SortEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DomainQueriesResponseV1> {
        const response = await this.searchConfigsV1Raw({ filter: filter, limit: limit, offset: offset, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Search Templates
     */
    async searchTemplatesV1Raw(
        requestParameters: DefaultApiSearchTemplatesV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainQueriesResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:read"]);
        }

        const response = await this.request(
            {
                path: `/forensics/queries/templates/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainQueriesResponseV1FromJSON(jsonValue));
    }

    /**
     * Search Templates
     */
    async searchTemplatesV1(
        filter?: string,
        limit?: string,
        offset?: string,
        sort?: SearchTemplatesV1SortEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DomainQueriesResponseV1> {
        const response = await this.searchTemplatesV1Raw({ filter: filter, limit: limit, offset: offset, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Configures all hosts in the provided host group to be ready to accept an execute API call
     */
    async v1HostConfigsPostRaw(
        requestParameters: DefaultApiV1HostConfigsPostRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<PluginsonpremapiOnPremConfigureResponse>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling v1HostConfigsPost().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["pluginsonprem:write"]);
        }

        const response = await this.request(
            {
                path: `/pluginsonprem/entities/host-configs/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: PluginsonpremapiOnPremConfigureRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => PluginsonpremapiOnPremConfigureResponseFromJSON(jsonValue));
    }

    /**
     * Configures all hosts in the provided host group to be ready to accept an execute API call
     */
    async v1HostConfigsPost(body: PluginsonpremapiOnPremConfigureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PluginsonpremapiOnPremConfigureResponse> {
        const response = await this.v1HostConfigsPostRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Fetches the host configs within the provided host group.
     */
    async v1StatusGetRaw(
        requestParameters: DefaultApiV1StatusGetRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<PluginsonpremapiOnPremGetHostConfigsResponse>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling v1StatusGet().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["pluginsonprem:read"]);
        }

        const response = await this.request(
            {
                path: `/pluginsonprem/entities/host-configs/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => PluginsonpremapiOnPremGetHostConfigsResponseFromJSON(jsonValue));
    }

    /**
     * Fetches the host configs within the provided host group.
     */
    async v1StatusGet(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PluginsonpremapiOnPremGetHostConfigsResponse> {
        const response = await this.v1StatusGetRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Validates a configuration collection
     */
    async validateCollectionV1Raw(
        requestParameters: DefaultApiValidateCollectionV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainResponseV1>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling validateCollectionV1().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:write"]);
        }

        const response = await this.request(
            {
                path: `/forensics/entities/collections-validate/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: DomainValidateCollectionRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainResponseV1FromJSON(jsonValue));
    }

    /**
     * Validates a configuration collection
     */
    async validateCollectionV1(body: DomainValidateCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainResponseV1> {
        const response = await this.validateCollectionV1Raw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Validates a custom configuration
     */
    async validateConfigV1Raw(requestParameters: DefaultApiValidateConfigV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DomainResponseV1>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling validateConfigV1().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["forensics-configs:write"]);
        }

        const response = await this.request(
            {
                path: `/forensics/entities/configurations-validate/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: DomainSaveConfigRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainResponseV1FromJSON(jsonValue));
    }

    /**
     * Validates a custom configuration
     */
    async validateConfigV1(body: DomainSaveConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainResponseV1> {
        const response = await this.validateConfigV1Raw({ body: body }, initOverrides);
        return await response.value();
    }
}

/**
 * @export
 */
export const GetCollectionCountsByV1SortEnum = {
    CollectionTagAsc: "collection_tag|asc",
    CollectionTagDesc: "collection_tag|desc",
    StateAsc: "state|asc",
    StateDesc: "state|desc",
} as const;
export type GetCollectionCountsByV1SortEnum = (typeof GetCollectionCountsByV1SortEnum)[keyof typeof GetCollectionCountsByV1SortEnum];
/**
 * @export
 */
export const GetCollectionsV1PlatformEnum = {
    Windows: "windows",
    Linux: "linux",
    Mac: "mac",
} as const;
export type GetCollectionsV1PlatformEnum = (typeof GetCollectionsV1PlatformEnum)[keyof typeof GetCollectionsV1PlatformEnum];
/**
 * @export
 */
export const GetCollectionsV1SortEnum = {
    DeadlineAsc: "deadline|asc",
    DeadlineDesc: "deadline|desc",
    IdAsc: "id|asc",
    IdDesc: "id|desc",
    PriorityAsc: "priority|asc",
    PriorityDesc: "priority|desc",
    StateAsc: "state|asc",
    StateDesc: "state|desc",
    ModifiedTimestampAsc: "modified_timestamp|asc",
    ModifiedTimestampDesc: "modified_timestamp|desc",
} as const;
export type GetCollectionsV1SortEnum = (typeof GetCollectionsV1SortEnum)[keyof typeof GetCollectionsV1SortEnum];
/**
 * @export
 */
export const GetCollectorsV1PlatformEnum = {
    Windows: "windows",
    Linux: "linux",
    Mac: "mac",
} as const;
export type GetCollectorsV1PlatformEnum = (typeof GetCollectorsV1PlatformEnum)[keyof typeof GetCollectorsV1PlatformEnum];
/**
 * @export
 */
export const GetCollectorsV1SortEnum = {
    Null: "null",
    AidAsc: "aid|asc",
    AidDesc: "aid|desc",
    FfcidAsc: "ffcid|asc",
    FfcidDesc: "ffcid|desc",
    PlatformAsc: "platform|asc",
    PlatformDesc: "platform|desc",
    ModifiedTimestampAsc: "modified_timestamp|asc",
    ModifiedTimestampDesc: "modified_timestamp|desc",
    StateAsc: "state|asc",
    StateDesc: "state|desc",
} as const;
export type GetCollectorsV1SortEnum = (typeof GetCollectorsV1SortEnum)[keyof typeof GetCollectorsV1SortEnum];
/**
 * @export
 */
export const GetCombinedCollectionsV1SortEnum = {
    DeadlineAsc: "deadline|asc",
    DeadlineDesc: "deadline|desc",
    IdAsc: "id|asc",
    IdDesc: "id|desc",
    PriorityAsc: "priority|asc",
    PriorityDesc: "priority|desc",
    StateAsc: "state|asc",
    StateDesc: "state|desc",
    ModifiedTimestampAsc: "modified_timestamp|asc",
    ModifiedTimestampDesc: "modified_timestamp|desc",
} as const;
export type GetCombinedCollectionsV1SortEnum = (typeof GetCombinedCollectionsV1SortEnum)[keyof typeof GetCombinedCollectionsV1SortEnum];
/**
 * @export
 */
export const GetCombinedCollectorsV1SortEnum = {
    Null: "null",
    AidAsc: "aid|asc",
    AidDesc: "aid|desc",
    FfcidAsc: "ffcid|asc",
    FfcidDesc: "ffcid|desc",
    PlatformAsc: "platform|asc",
    PlatformDesc: "platform|desc",
    ModifiedTimestampAsc: "modified_timestamp|asc",
    ModifiedTimestampDesc: "modified_timestamp|desc",
    StateAsc: "state|asc",
    StateDesc: "state|desc",
} as const;
export type GetCombinedCollectorsV1SortEnum = (typeof GetCombinedCollectorsV1SortEnum)[keyof typeof GetCombinedCollectorsV1SortEnum];
/**
 * @export
 */
export const GetCombinedConfigsV1SortEnum = {
    Null: "null",
    IdAsc: "id|asc",
    IdDesc: "id|desc",
    NameAsc: "name|asc",
    NameDesc: "name|desc",
    ModifiedTimestampAsc: "modified_timestamp|asc",
    ModifiedTimestampDesc: "modified_timestamp|desc",
} as const;
export type GetCombinedConfigsV1SortEnum = (typeof GetCombinedConfigsV1SortEnum)[keyof typeof GetCombinedConfigsV1SortEnum];
/**
 * @export
 */
export const GetCombinedTemplatesV1SortEnum = {
    IdAsc: "id|asc",
    IdDesc: "id|desc",
    NameAsc: "name|asc",
    NameDesc: "name|desc",
    ModifiedTimestampAsc: "modified_timestamp|asc",
    ModifiedTimestampDesc: "modified_timestamp|desc",
} as const;
export type GetCombinedTemplatesV1SortEnum = (typeof GetCombinedTemplatesV1SortEnum)[keyof typeof GetCombinedTemplatesV1SortEnum];
/**
 * @export
 */
export const SearchCollectionsV1PlatformEnum = {
    Windows: "windows",
    Linux: "linux",
    Mac: "mac",
} as const;
export type SearchCollectionsV1PlatformEnum = (typeof SearchCollectionsV1PlatformEnum)[keyof typeof SearchCollectionsV1PlatformEnum];
/**
 * @export
 */
export const SearchCollectionsV1SortEnum = {
    DeadlineAsc: "deadline|asc",
    DeadlineDesc: "deadline|desc",
    IdAsc: "id|asc",
    IdDesc: "id|desc",
    PriorityAsc: "priority|asc",
    PriorityDesc: "priority|desc",
    StateAsc: "state|asc",
    StateDesc: "state|desc",
    ModifiedTimestampAsc: "modified_timestamp|asc",
    ModifiedTimestampDesc: "modified_timestamp|desc",
} as const;
export type SearchCollectionsV1SortEnum = (typeof SearchCollectionsV1SortEnum)[keyof typeof SearchCollectionsV1SortEnum];
/**
 * @export
 */
export const SearchCollectorsV1PlatformEnum = {
    Windows: "windows",
    Linux: "linux",
    Mac: "mac",
} as const;
export type SearchCollectorsV1PlatformEnum = (typeof SearchCollectorsV1PlatformEnum)[keyof typeof SearchCollectorsV1PlatformEnum];
/**
 * @export
 */
export const SearchCollectorsV1SortEnum = {
    Null: "null",
    AidAsc: "aid|asc",
    AidDesc: "aid|desc",
    FfcidAsc: "ffcid|asc",
    FfcidDesc: "ffcid|desc",
    PlatformAsc: "platform|asc",
    PlatformDesc: "platform|desc",
    ModifiedTimestampAsc: "modified_timestamp|asc",
    ModifiedTimestampDesc: "modified_timestamp|desc",
} as const;
export type SearchCollectorsV1SortEnum = (typeof SearchCollectorsV1SortEnum)[keyof typeof SearchCollectorsV1SortEnum];
/**
 * @export
 */
export const SearchConfigsV1SortEnum = {
    IdAsc: "id|asc",
    IdDesc: "id|desc",
    NameAsc: "name|asc",
    NameDesc: "name|desc",
    ModifiedTimestampAsc: "modified_timestamp|asc",
    ModifiedTimestampDesc: "modified_timestamp|desc",
} as const;
export type SearchConfigsV1SortEnum = (typeof SearchConfigsV1SortEnum)[keyof typeof SearchConfigsV1SortEnum];
/**
 * @export
 */
export const SearchTemplatesV1SortEnum = {
    IdAsc: "id|asc",
    IdDesc: "id|desc",
    NameAsc: "name|asc",
    NameDesc: "name|desc",
    ModifiedTimestampAsc: "modified_timestamp|asc",
    ModifiedTimestampDesc: "modified_timestamp|desc",
} as const;
export type SearchTemplatesV1SortEnum = (typeof SearchTemplatesV1SortEnum)[keyof typeof SearchTemplatesV1SortEnum];
