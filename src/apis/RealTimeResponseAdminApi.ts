/* tslint:disable */
/* eslint-disable */
/**
 * CrowdStrike API Specification
 * Use this API specification as a reference for the API endpoints you can use to interact with your Falcon environment. These endpoints support authentication via OAuth2 and interact with detections and network containment. For detailed usage guides and examples, see our [documentation inside the Falcon console](https://falcon.crowdstrike.com/support/documentation).     To use the APIs described below, combine the base URL with the path shown for each API endpoint. For commercial cloud customers, your base URL is `https://api.crowdstrike.com`.    Each API endpoint requires authorization via an OAuth2 token. Your first API request should retrieve an OAuth2 token using the `oauth2/token` endpoint, such as `https://api.crowdstrike.com/oauth2/token`. For subsequent requests, include the OAuth2 token in an HTTP authorization header. Tokens expire after 30 minutes, after which you should make a new token request to continue making API requests.
 *
 * The version of the OpenAPI document: rolling
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
    BinservapiMsaPutFileResponse,
    DomainAPIError,
    DomainBatchExecuteCommandRequest,
    DomainCommandExecuteRequest,
    DomainCommandExecuteResponseWrapper,
    DomainMultiCommandExecuteResponseWrapper,
    DomainStatusResponseWrapper,
    EmpowerapiMsaFalconScriptResponse,
    EmpowerapiMsaIDListResponse,
    EmpowerapiMsaPFResponseV1,
    EmpowerapiMsaPFResponseV2,
    MsaErrorsOnly,
    MsaReplyMetaOnly,
} from "../models/index";
import {
    BinservapiMsaPutFileResponseFromJSON,
    BinservapiMsaPutFileResponseToJSON,
    DomainAPIErrorFromJSON,
    DomainAPIErrorToJSON,
    DomainBatchExecuteCommandRequestFromJSON,
    DomainBatchExecuteCommandRequestToJSON,
    DomainCommandExecuteRequestFromJSON,
    DomainCommandExecuteRequestToJSON,
    DomainCommandExecuteResponseWrapperFromJSON,
    DomainCommandExecuteResponseWrapperToJSON,
    DomainMultiCommandExecuteResponseWrapperFromJSON,
    DomainMultiCommandExecuteResponseWrapperToJSON,
    DomainStatusResponseWrapperFromJSON,
    DomainStatusResponseWrapperToJSON,
    EmpowerapiMsaFalconScriptResponseFromJSON,
    EmpowerapiMsaFalconScriptResponseToJSON,
    EmpowerapiMsaIDListResponseFromJSON,
    EmpowerapiMsaIDListResponseToJSON,
    EmpowerapiMsaPFResponseV1FromJSON,
    EmpowerapiMsaPFResponseV1ToJSON,
    EmpowerapiMsaPFResponseV2FromJSON,
    EmpowerapiMsaPFResponseV2ToJSON,
    MsaErrorsOnlyFromJSON,
    MsaErrorsOnlyToJSON,
    MsaReplyMetaOnlyFromJSON,
    MsaReplyMetaOnlyToJSON,
} from "../models/index";

export interface RealTimeResponseAdminApiBatchAdminCmdRequest {
    body: DomainBatchExecuteCommandRequest;
    timeout?: number;
    timeoutDuration?: string;
    hostTimeoutDuration?: string;
}

export interface RealTimeResponseAdminApiRTRCheckAdminCommandStatusRequest {
    cloudRequestId: string;
    sequenceId: number;
}

export interface RealTimeResponseAdminApiRTRCreatePutFilesRequest {
    file: Blob;
    description: string;
    name?: string;
    commentsForAuditLog?: string;
}

export interface RealTimeResponseAdminApiRTRCreateScriptsRequest {
    description: string;
    permissionType: string;
    file?: Blob;
    name?: string;
    commentsForAuditLog?: string;
    content?: string;
    platform?: Array<string>;
}

export interface RealTimeResponseAdminApiRTRDeletePutFilesRequest {
    ids: string;
}

export interface RealTimeResponseAdminApiRTRDeleteScriptsRequest {
    ids: string;
}

export interface RealTimeResponseAdminApiRTRExecuteAdminCommandRequest {
    body: DomainCommandExecuteRequest;
}

export interface RealTimeResponseAdminApiRTRGetFalconScriptsRequest {
    ids: Array<string>;
}

export interface RealTimeResponseAdminApiRTRGetPutFilesRequest {
    ids: Array<string>;
}

export interface RealTimeResponseAdminApiRTRGetPutFilesV2Request {
    ids: Array<string>;
}

export interface RealTimeResponseAdminApiRTRGetScriptsRequest {
    ids: Array<string>;
}

export interface RealTimeResponseAdminApiRTRGetScriptsV2Request {
    ids: Array<string>;
}

export interface RealTimeResponseAdminApiRTRListFalconScriptsRequest {
    filter?: string;
    offset?: number;
    limit?: number;
    sort?: RTRListFalconScriptsSortEnum;
}

export interface RealTimeResponseAdminApiRTRListPutFilesRequest {
    filter?: string;
    offset?: string;
    limit?: number;
    sort?: string;
}

export interface RealTimeResponseAdminApiRTRListScriptsRequest {
    filter?: string;
    offset?: string;
    limit?: number;
    sort?: string;
}

export interface RealTimeResponseAdminApiRTRUpdateScriptsRequest {
    id: string;
    file?: Blob;
    description?: string;
    name?: string;
    commentsForAuditLog?: string;
    permissionType?: string;
    content?: string;
    platform?: Array<string>;
}

/**
 *
 */
export class RealTimeResponseAdminApi extends runtime.BaseAPI {
    /**
     * Batch executes a RTR administrator command across the hosts mapped to the given batch ID.
     */
    async batchAdminCmdRaw(
        requestParameters: RealTimeResponseAdminApiBatchAdminCmdRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainMultiCommandExecuteResponseWrapper>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling batchAdminCmd().');
        }

        const queryParameters: any = {};

        if (requestParameters["timeout"] != null) {
            queryParameters["timeout"] = requestParameters["timeout"];
        }

        if (requestParameters["timeoutDuration"] != null) {
            queryParameters["timeout_duration"] = requestParameters["timeoutDuration"];
        }

        if (requestParameters["hostTimeoutDuration"] != null) {
            queryParameters["host_timeout_duration"] = requestParameters["hostTimeoutDuration"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/real-time-response/combined/batch-admin-command/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: DomainBatchExecuteCommandRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainMultiCommandExecuteResponseWrapperFromJSON(jsonValue));
    }

    /**
     * Batch executes a RTR administrator command across the hosts mapped to the given batch ID.
     */
    async batchAdminCmd(
        body: DomainBatchExecuteCommandRequest,
        timeout?: number,
        timeoutDuration?: string,
        hostTimeoutDuration?: string,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DomainMultiCommandExecuteResponseWrapper> {
        const response = await this.batchAdminCmdRaw({ body: body, timeout: timeout, timeoutDuration: timeoutDuration, hostTimeoutDuration: hostTimeoutDuration }, initOverrides);
        return await response.value();
    }

    /**
     * Get status of an executed RTR administrator command on a single host.
     */
    async rTRCheckAdminCommandStatusRaw(
        requestParameters: RealTimeResponseAdminApiRTRCheckAdminCommandStatusRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainStatusResponseWrapper>> {
        if (requestParameters["cloudRequestId"] == null) {
            throw new runtime.RequiredError("cloudRequestId", 'Required parameter "cloudRequestId" was null or undefined when calling rTRCheckAdminCommandStatus().');
        }

        if (requestParameters["sequenceId"] == null) {
            throw new runtime.RequiredError("sequenceId", 'Required parameter "sequenceId" was null or undefined when calling rTRCheckAdminCommandStatus().');
        }

        const queryParameters: any = {};

        if (requestParameters["cloudRequestId"] != null) {
            queryParameters["cloud_request_id"] = requestParameters["cloudRequestId"];
        }

        if (requestParameters["sequenceId"] != null) {
            queryParameters["sequence_id"] = requestParameters["sequenceId"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/real-time-response/entities/admin-command/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainStatusResponseWrapperFromJSON(jsonValue));
    }

    /**
     * Get status of an executed RTR administrator command on a single host.
     */
    async rTRCheckAdminCommandStatus(cloudRequestId: string, sequenceId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainStatusResponseWrapper> {
        const response = await this.rTRCheckAdminCommandStatusRaw({ cloudRequestId: cloudRequestId, sequenceId: sequenceId }, initOverrides);
        return await response.value();
    }

    /**
     * Upload a new put-file to use for the RTR `put` command.
     */
    async rTRCreatePutFilesRaw(
        requestParameters: RealTimeResponseAdminApiRTRCreatePutFilesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<MsaReplyMetaOnly>> {
        if (requestParameters["file"] == null) {
            throw new runtime.RequiredError("file", 'Required parameter "file" was null or undefined when calling rTRCreatePutFiles().');
        }

        if (requestParameters["description"] == null) {
            throw new runtime.RequiredError("description", 'Required parameter "description" was null or undefined when calling rTRCreatePutFiles().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const consumes: runtime.Consume[] = [{ contentType: "multipart/form-data" }];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters["file"] != null) {
            formParams.append("file", requestParameters["file"] as any);
        }

        if (requestParameters["description"] != null) {
            formParams.append("description", requestParameters["description"] as any);
        }

        if (requestParameters["name"] != null) {
            formParams.append("name", requestParameters["name"] as any);
        }

        if (requestParameters["commentsForAuditLog"] != null) {
            formParams.append("comments_for_audit_log", requestParameters["commentsForAuditLog"] as any);
        }

        const response = await this.request(
            {
                path: `/real-time-response/entities/put-files/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaReplyMetaOnlyFromJSON(jsonValue));
    }

    /**
     * Upload a new put-file to use for the RTR `put` command.
     */
    async rTRCreatePutFiles(file: Blob, description: string, name?: string, commentsForAuditLog?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MsaReplyMetaOnly> {
        const response = await this.rTRCreatePutFilesRaw({ file: file, description: description, name: name, commentsForAuditLog: commentsForAuditLog }, initOverrides);
        return await response.value();
    }

    /**
     * Upload a new custom-script to use for the RTR `runscript` command.
     */
    async rTRCreateScriptsRaw(
        requestParameters: RealTimeResponseAdminApiRTRCreateScriptsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<MsaReplyMetaOnly>> {
        if (requestParameters["description"] == null) {
            throw new runtime.RequiredError("description", 'Required parameter "description" was null or undefined when calling rTRCreateScripts().');
        }

        if (requestParameters["permissionType"] == null) {
            throw new runtime.RequiredError("permissionType", 'Required parameter "permissionType" was null or undefined when calling rTRCreateScripts().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const consumes: runtime.Consume[] = [{ contentType: "multipart/form-data" }];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters["file"] != null) {
            formParams.append("file", requestParameters["file"] as any);
        }

        if (requestParameters["description"] != null) {
            formParams.append("description", requestParameters["description"] as any);
        }

        if (requestParameters["name"] != null) {
            formParams.append("name", requestParameters["name"] as any);
        }

        if (requestParameters["commentsForAuditLog"] != null) {
            formParams.append("comments_for_audit_log", requestParameters["commentsForAuditLog"] as any);
        }

        if (requestParameters["permissionType"] != null) {
            formParams.append("permission_type", requestParameters["permissionType"] as any);
        }

        if (requestParameters["content"] != null) {
            formParams.append("content", requestParameters["content"] as any);
        }

        if (requestParameters["platform"] != null) {
            formParams.append("platform", requestParameters["platform"]!.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        const response = await this.request(
            {
                path: `/real-time-response/entities/scripts/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaReplyMetaOnlyFromJSON(jsonValue));
    }

    /**
     * Upload a new custom-script to use for the RTR `runscript` command.
     */
    async rTRCreateScripts(
        description: string,
        permissionType: string,
        file?: Blob,
        name?: string,
        commentsForAuditLog?: string,
        content?: string,
        platform?: Array<string>,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<MsaReplyMetaOnly> {
        const response = await this.rTRCreateScriptsRaw(
            { description: description, permissionType: permissionType, file: file, name: name, commentsForAuditLog: commentsForAuditLog, content: content, platform: platform },
            initOverrides,
        );
        return await response.value();
    }

    /**
     * Delete a put-file based on the ID given.  Can only delete one file at a time.
     */
    async rTRDeletePutFilesRaw(
        requestParameters: RealTimeResponseAdminApiRTRDeletePutFilesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<MsaReplyMetaOnly>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling rTRDeletePutFiles().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/real-time-response/entities/put-files/v1`,
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaReplyMetaOnlyFromJSON(jsonValue));
    }

    /**
     * Delete a put-file based on the ID given.  Can only delete one file at a time.
     */
    async rTRDeletePutFiles(ids: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MsaReplyMetaOnly> {
        const response = await this.rTRDeletePutFilesRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Delete a custom-script based on the ID given.  Can only delete one script at a time.
     */
    async rTRDeleteScriptsRaw(
        requestParameters: RealTimeResponseAdminApiRTRDeleteScriptsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<MsaReplyMetaOnly>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling rTRDeleteScripts().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/real-time-response/entities/scripts/v1`,
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaReplyMetaOnlyFromJSON(jsonValue));
    }

    /**
     * Delete a custom-script based on the ID given.  Can only delete one script at a time.
     */
    async rTRDeleteScripts(ids: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MsaReplyMetaOnly> {
        const response = await this.rTRDeleteScriptsRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Execute a RTR administrator command on a single host.
     */
    async rTRExecuteAdminCommandRaw(
        requestParameters: RealTimeResponseAdminApiRTRExecuteAdminCommandRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DomainCommandExecuteResponseWrapper>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling rTRExecuteAdminCommand().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/real-time-response/entities/admin-command/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: DomainCommandExecuteRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainCommandExecuteResponseWrapperFromJSON(jsonValue));
    }

    /**
     * Execute a RTR administrator command on a single host.
     */
    async rTRExecuteAdminCommand(body: DomainCommandExecuteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DomainCommandExecuteResponseWrapper> {
        const response = await this.rTRExecuteAdminCommandRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Get Falcon scripts with metadata and content of script
     */
    async rTRGetFalconScriptsRaw(
        requestParameters: RealTimeResponseAdminApiRTRGetFalconScriptsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<EmpowerapiMsaFalconScriptResponse>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling rTRGetFalconScripts().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/real-time-response/entities/falcon-scripts/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => EmpowerapiMsaFalconScriptResponseFromJSON(jsonValue));
    }

    /**
     * Get Falcon scripts with metadata and content of script
     */
    async rTRGetFalconScripts(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EmpowerapiMsaFalconScriptResponse> {
        const response = await this.rTRGetFalconScriptsRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Get put-files based on the ID\'s given. These are used for the RTR `put` command.
     */
    async rTRGetPutFilesRaw(
        requestParameters: RealTimeResponseAdminApiRTRGetPutFilesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<EmpowerapiMsaPFResponseV1>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling rTRGetPutFiles().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/real-time-response/entities/put-files/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => EmpowerapiMsaPFResponseV1FromJSON(jsonValue));
    }

    /**
     * Get put-files based on the ID\'s given. These are used for the RTR `put` command.
     */
    async rTRGetPutFiles(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EmpowerapiMsaPFResponseV1> {
        const response = await this.rTRGetPutFilesRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Get put-files based on the ID\'s given. These are used for the RTR `put` command.
     */
    async rTRGetPutFilesV2Raw(
        requestParameters: RealTimeResponseAdminApiRTRGetPutFilesV2Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<EmpowerapiMsaPFResponseV2>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling rTRGetPutFilesV2().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/real-time-response/entities/put-files/v2`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => EmpowerapiMsaPFResponseV2FromJSON(jsonValue));
    }

    /**
     * Get put-files based on the ID\'s given. These are used for the RTR `put` command.
     */
    async rTRGetPutFilesV2(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EmpowerapiMsaPFResponseV2> {
        const response = await this.rTRGetPutFilesV2Raw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Get custom-scripts based on the ID\'s given. These are used for the RTR `runscript` command.
     */
    async rTRGetScriptsRaw(
        requestParameters: RealTimeResponseAdminApiRTRGetScriptsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<EmpowerapiMsaPFResponseV1>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling rTRGetScripts().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/real-time-response/entities/scripts/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => EmpowerapiMsaPFResponseV1FromJSON(jsonValue));
    }

    /**
     * Get custom-scripts based on the ID\'s given. These are used for the RTR `runscript` command.
     */
    async rTRGetScripts(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EmpowerapiMsaPFResponseV1> {
        const response = await this.rTRGetScriptsRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Get custom-scripts based on the ID\'s given. These are used for the RTR `runscript` command.
     */
    async rTRGetScriptsV2Raw(
        requestParameters: RealTimeResponseAdminApiRTRGetScriptsV2Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<EmpowerapiMsaPFResponseV2>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling rTRGetScriptsV2().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/real-time-response/entities/scripts/v2`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => EmpowerapiMsaPFResponseV2FromJSON(jsonValue));
    }

    /**
     * Get custom-scripts based on the ID\'s given. These are used for the RTR `runscript` command.
     */
    async rTRGetScriptsV2(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EmpowerapiMsaPFResponseV2> {
        const response = await this.rTRGetScriptsV2Raw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of Falcon script IDs available to the user to run
     */
    async rTRListFalconScriptsRaw(
        requestParameters: RealTimeResponseAdminApiRTRListFalconScriptsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<EmpowerapiMsaIDListResponse>> {
        const queryParameters: any = {};

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/real-time-response/queries/falcon-scripts/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => EmpowerapiMsaIDListResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of Falcon script IDs available to the user to run
     */
    async rTRListFalconScripts(
        filter?: string,
        offset?: number,
        limit?: number,
        sort?: RTRListFalconScriptsSortEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<EmpowerapiMsaIDListResponse> {
        const response = await this.rTRListFalconScriptsRaw({ filter: filter, offset: offset, limit: limit, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of put-file ID\'s that are available to the user for the `put` command.
     */
    async rTRListPutFilesRaw(
        requestParameters: RealTimeResponseAdminApiRTRListPutFilesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<BinservapiMsaPutFileResponse>> {
        const queryParameters: any = {};

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/real-time-response/queries/put-files/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => BinservapiMsaPutFileResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of put-file ID\'s that are available to the user for the `put` command.
     */
    async rTRListPutFiles(filter?: string, offset?: string, limit?: number, sort?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BinservapiMsaPutFileResponse> {
        const response = await this.rTRListPutFilesRaw({ filter: filter, offset: offset, limit: limit, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of custom-script ID\'s that are available to the user for the `runscript` command.
     */
    async rTRListScriptsRaw(
        requestParameters: RealTimeResponseAdminApiRTRListScriptsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<BinservapiMsaPutFileResponse>> {
        const queryParameters: any = {};

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request(
            {
                path: `/real-time-response/queries/scripts/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => BinservapiMsaPutFileResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of custom-script ID\'s that are available to the user for the `runscript` command.
     */
    async rTRListScripts(filter?: string, offset?: string, limit?: number, sort?: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BinservapiMsaPutFileResponse> {
        const response = await this.rTRListScriptsRaw({ filter: filter, offset: offset, limit: limit, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Upload a new scripts to replace an existing one.
     */
    async rTRUpdateScriptsRaw(
        requestParameters: RealTimeResponseAdminApiRTRUpdateScriptsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<MsaReplyMetaOnly>> {
        if (requestParameters["id"] == null) {
            throw new runtime.RequiredError("id", 'Required parameter "id" was null or undefined when calling rTRUpdateScripts().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const consumes: runtime.Consume[] = [{ contentType: "multipart/form-data" }];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters["id"] != null) {
            formParams.append("id", requestParameters["id"] as any);
        }

        if (requestParameters["file"] != null) {
            formParams.append("file", requestParameters["file"] as any);
        }

        if (requestParameters["description"] != null) {
            formParams.append("description", requestParameters["description"] as any);
        }

        if (requestParameters["name"] != null) {
            formParams.append("name", requestParameters["name"] as any);
        }

        if (requestParameters["commentsForAuditLog"] != null) {
            formParams.append("comments_for_audit_log", requestParameters["commentsForAuditLog"] as any);
        }

        if (requestParameters["permissionType"] != null) {
            formParams.append("permission_type", requestParameters["permissionType"] as any);
        }

        if (requestParameters["content"] != null) {
            formParams.append("content", requestParameters["content"] as any);
        }

        if (requestParameters["platform"] != null) {
            formParams.append("platform", requestParameters["platform"]!.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        const response = await this.request(
            {
                path: `/real-time-response/entities/scripts/v1`,
                method: "PATCH",
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaReplyMetaOnlyFromJSON(jsonValue));
    }

    /**
     * Upload a new scripts to replace an existing one.
     */
    async rTRUpdateScripts(
        id: string,
        file?: Blob,
        description?: string,
        name?: string,
        commentsForAuditLog?: string,
        permissionType?: string,
        content?: string,
        platform?: Array<string>,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<MsaReplyMetaOnly> {
        const response = await this.rTRUpdateScriptsRaw(
            { id: id, file: file, description: description, name: name, commentsForAuditLog: commentsForAuditLog, permissionType: permissionType, content: content, platform: platform },
            initOverrides,
        );
        return await response.value();
    }
}

/**
 * @export
 */
export const RTRListFalconScriptsSortEnum = {
    CreatedTimestamp: "created_timestamp",
    ModifiedTimestamp: "modified_timestamp",
    Name: "name",
} as const;
export type RTRListFalconScriptsSortEnum = (typeof RTRListFalconScriptsSortEnum)[keyof typeof RTRListFalconScriptsSortEnum];
