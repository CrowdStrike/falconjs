/* tslint:disable */
/* eslint-disable */
/**
 * CrowdStrike API Specification
 * Use this API specification as a reference for the API endpoints you can use to interact with your Falcon environment. These endpoints support authentication via OAuth2 and interact with detections and network containment. For detailed usage guides and examples, see our [documentation inside the Falcon console](https://falcon.crowdstrike.com/support/documentation).     To use the APIs described below, combine the base URL with the path shown for each API endpoint. For commercial cloud customers, your base URL is `https://api.crowdstrike.com`.    Each API endpoint requires authorization via an OAuth2 token. Your first API request should retrieve an OAuth2 token using the `oauth2/token` endpoint, such as `https://api.crowdstrike.com/oauth2/token`. For subsequent requests, include the OAuth2 token in an HTTP authorization header. Tokens expire after 30 minutes, after which you should make a new token request to continue making API requests.
 *
 * The version of the OpenAPI document: rolling
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
    ApiCreateDashboardFromTemplateResponseV1,
    ApiCreateLookupFileResponseV1,
    ApiCreateParserFromTemplateResponseV1,
    ApiCreateParserRequestV1,
    ApiCreateParserResponseV1,
    ApiCreateSavedQueryResponseV1,
    ApiDeleteDashboardResponseV1,
    ApiDeleteLookupFileResponseV1,
    ApiDeleteParserResponseV1,
    ApiDeleteSavedQueryResponseV1,
    ApiGetDashboardTemplateResponseV1,
    ApiGetParserResponseV1,
    ApiGetParserTemplateResponseV1,
    ApiGetSavedQueryResponseV1,
    ApiListDashboardsResponseV1,
    ApiListLookupFilesResponseV1,
    ApiListParsersResponseV1,
    ApiListSavedQueriesResponseV1,
    ApiQueryJobInput,
    ApiQueryJobResponse,
    ApiQueryJobsResults,
    ApiUpdateDashboardFromTemplateResponseV1,
    ApiUpdateLookupFileEntriesResponseV1,
    ApiUpdateLookupFileResponseV1,
    ApiUpdateParserFromTemplateResponseV1,
    ApiUpdateParserRequestV1,
    ApiUpdateParserResponseV1,
    ApiUpdateSavedQueryResponseV1,
    DataconnectionmanagementConfigResponse,
    DataconnectionmanagementConnectionNotReady,
    DataconnectionmanagementConnectionStatusResponse,
    DataconnectionmanagementConnectionTokenResponse,
    DataconnectionmanagementCreateDataConnectionRequest,
    DataconnectionmanagementDataConnectionResponse,
    DataconnectionmanagementDataConnectorResponse,
    DataconnectionmanagementGenericResourcesResponse,
    DataconnectionmanagementUpdateDataConnectionRequest,
    DataconnectionmanagementUpdateDataConnectionStatusRequest,
    MsaAPIError,
    MsaReplyAffectedEntities,
    MsaReplyMetaOnly,
    MsaspecResponseFields,
} from "../models/index";
import {
    ApiCreateDashboardFromTemplateResponseV1FromJSON,
    ApiCreateDashboardFromTemplateResponseV1ToJSON,
    ApiCreateLookupFileResponseV1FromJSON,
    ApiCreateLookupFileResponseV1ToJSON,
    ApiCreateParserFromTemplateResponseV1FromJSON,
    ApiCreateParserFromTemplateResponseV1ToJSON,
    ApiCreateParserRequestV1FromJSON,
    ApiCreateParserRequestV1ToJSON,
    ApiCreateParserResponseV1FromJSON,
    ApiCreateParserResponseV1ToJSON,
    ApiCreateSavedQueryResponseV1FromJSON,
    ApiCreateSavedQueryResponseV1ToJSON,
    ApiDeleteDashboardResponseV1FromJSON,
    ApiDeleteDashboardResponseV1ToJSON,
    ApiDeleteLookupFileResponseV1FromJSON,
    ApiDeleteLookupFileResponseV1ToJSON,
    ApiDeleteParserResponseV1FromJSON,
    ApiDeleteParserResponseV1ToJSON,
    ApiDeleteSavedQueryResponseV1FromJSON,
    ApiDeleteSavedQueryResponseV1ToJSON,
    ApiGetDashboardTemplateResponseV1FromJSON,
    ApiGetDashboardTemplateResponseV1ToJSON,
    ApiGetParserResponseV1FromJSON,
    ApiGetParserResponseV1ToJSON,
    ApiGetParserTemplateResponseV1FromJSON,
    ApiGetParserTemplateResponseV1ToJSON,
    ApiGetSavedQueryResponseV1FromJSON,
    ApiGetSavedQueryResponseV1ToJSON,
    ApiListDashboardsResponseV1FromJSON,
    ApiListDashboardsResponseV1ToJSON,
    ApiListLookupFilesResponseV1FromJSON,
    ApiListLookupFilesResponseV1ToJSON,
    ApiListParsersResponseV1FromJSON,
    ApiListParsersResponseV1ToJSON,
    ApiListSavedQueriesResponseV1FromJSON,
    ApiListSavedQueriesResponseV1ToJSON,
    ApiQueryJobInputFromJSON,
    ApiQueryJobInputToJSON,
    ApiQueryJobResponseFromJSON,
    ApiQueryJobResponseToJSON,
    ApiQueryJobsResultsFromJSON,
    ApiQueryJobsResultsToJSON,
    ApiUpdateDashboardFromTemplateResponseV1FromJSON,
    ApiUpdateDashboardFromTemplateResponseV1ToJSON,
    ApiUpdateLookupFileEntriesResponseV1FromJSON,
    ApiUpdateLookupFileEntriesResponseV1ToJSON,
    ApiUpdateLookupFileResponseV1FromJSON,
    ApiUpdateLookupFileResponseV1ToJSON,
    ApiUpdateParserFromTemplateResponseV1FromJSON,
    ApiUpdateParserFromTemplateResponseV1ToJSON,
    ApiUpdateParserRequestV1FromJSON,
    ApiUpdateParserRequestV1ToJSON,
    ApiUpdateParserResponseV1FromJSON,
    ApiUpdateParserResponseV1ToJSON,
    ApiUpdateSavedQueryResponseV1FromJSON,
    ApiUpdateSavedQueryResponseV1ToJSON,
    DataconnectionmanagementConfigResponseFromJSON,
    DataconnectionmanagementConfigResponseToJSON,
    DataconnectionmanagementConnectionNotReadyFromJSON,
    DataconnectionmanagementConnectionNotReadyToJSON,
    DataconnectionmanagementConnectionStatusResponseFromJSON,
    DataconnectionmanagementConnectionStatusResponseToJSON,
    DataconnectionmanagementConnectionTokenResponseFromJSON,
    DataconnectionmanagementConnectionTokenResponseToJSON,
    DataconnectionmanagementCreateDataConnectionRequestFromJSON,
    DataconnectionmanagementCreateDataConnectionRequestToJSON,
    DataconnectionmanagementDataConnectionResponseFromJSON,
    DataconnectionmanagementDataConnectionResponseToJSON,
    DataconnectionmanagementDataConnectorResponseFromJSON,
    DataconnectionmanagementDataConnectorResponseToJSON,
    DataconnectionmanagementGenericResourcesResponseFromJSON,
    DataconnectionmanagementGenericResourcesResponseToJSON,
    DataconnectionmanagementUpdateDataConnectionRequestFromJSON,
    DataconnectionmanagementUpdateDataConnectionRequestToJSON,
    DataconnectionmanagementUpdateDataConnectionStatusRequestFromJSON,
    DataconnectionmanagementUpdateDataConnectionStatusRequestToJSON,
    MsaAPIErrorFromJSON,
    MsaAPIErrorToJSON,
    MsaReplyAffectedEntitiesFromJSON,
    MsaReplyAffectedEntitiesToJSON,
    MsaReplyMetaOnlyFromJSON,
    MsaReplyMetaOnlyToJSON,
    MsaspecResponseFieldsFromJSON,
    MsaspecResponseFieldsToJSON,
} from "../models/index";

export interface NgsiemApiCreateDashboardFromTemplateRequest {
    searchDomain?: CreateDashboardFromTemplateSearchDomainEnum;
    name?: string;
    yamlTemplate?: Blob;
}

export interface NgsiemApiCreateLookupFileRequest {
    searchDomain?: CreateLookupFileSearchDomainEnum;
    filename?: string;
    file?: Blob;
}

export interface NgsiemApiCreateParserRequest {
    body: ApiCreateParserRequestV1;
}

export interface NgsiemApiCreateParserFromTemplateRequest {
    repository?: CreateParserFromTemplateRepositoryEnum;
    yamlTemplate?: Blob;
}

export interface NgsiemApiCreateSavedQueryRequest {
    searchDomain?: CreateSavedQuerySearchDomainEnum;
    yamlTemplate?: Blob;
}

export interface NgsiemApiDeleteDashboardRequest {
    ids?: string;
    searchDomain?: DeleteDashboardSearchDomainEnum;
}

export interface NgsiemApiDeleteLookupFileRequest {
    filename?: string;
    searchDomain?: DeleteLookupFileSearchDomainEnum;
}

export interface NgsiemApiDeleteParserRequest {
    ids?: string;
    repository?: DeleteParserRepositoryEnum;
}

export interface NgsiemApiDeleteSavedQueryRequest {
    ids?: string;
    searchDomain?: DeleteSavedQuerySearchDomainEnum;
}

export interface NgsiemApiExternalCreateDataConnectionRequest {
    body: DataconnectionmanagementCreateDataConnectionRequest;
}

export interface NgsiemApiExternalDeleteDataConnectionRequest {
    ids: string;
}

export interface NgsiemApiExternalGetDataConnectionByIDRequest {
    ids: Array<string>;
}

export interface NgsiemApiExternalGetDataConnectionStatusRequest {
    ids: Array<string>;
}

export interface NgsiemApiExternalGetDataConnectionTokenRequest {
    ids: string;
}

export interface NgsiemApiExternalListConnectorConfigsRequest {
    ids: string;
}

export interface NgsiemApiExternalListDataConnectionsRequest {
    filter?: string;
    offset?: number;
    limit?: number;
    sort?: string;
}

export interface NgsiemApiExternalListDataConnectorsRequest {
    filter?: string;
    offset?: number;
    limit?: number;
    sort?: string;
}

export interface NgsiemApiExternalRegenerateDataConnectionTokenRequest {
    ids: string;
}

export interface NgsiemApiExternalUpdateDataConnectionRequest {
    ids: string;
    body: DataconnectionmanagementUpdateDataConnectionRequest;
}

export interface NgsiemApiExternalUpdateDataConnectionStatusRequest {
    ids: string;
    body: DataconnectionmanagementUpdateDataConnectionStatusRequest;
}

export interface NgsiemApiGetDashboardTemplateRequest {
    ids?: string;
    searchDomain?: GetDashboardTemplateSearchDomainEnum;
}

export interface NgsiemApiGetLookupFileRequest {
    filename?: string;
    searchDomain?: GetLookupFileSearchDomainEnum;
}

export interface NgsiemApiGetLookupFromPackageV1Request {
    repository: string;
    _package: string;
    filename: string;
}

export interface NgsiemApiGetLookupFromPackageWithNamespaceV1Request {
    repository: string;
    namespace: string;
    _package: string;
    filename: string;
}

export interface NgsiemApiGetLookupV1Request {
    repository: string;
    filename: string;
}

export interface NgsiemApiGetParserRequest {
    ids?: string;
    repository?: GetParserRepositoryEnum;
}

export interface NgsiemApiGetParserTemplateRequest {
    ids?: string;
    repository?: GetParserTemplateRepositoryEnum;
}

export interface NgsiemApiGetSavedQueryTemplateRequest {
    ids?: string;
    searchDomain?: GetSavedQueryTemplateSearchDomainEnum;
}

export interface NgsiemApiGetSearchStatusV1Request {
    repository: string;
    id: string;
}

export interface NgsiemApiListDashboardsRequest {
    limit?: string;
    offset?: string;
    filter?: string;
    searchDomain?: ListDashboardsSearchDomainEnum;
}

export interface NgsiemApiListLookupFilesRequest {
    limit?: string;
    offset?: string;
    filter?: string;
    searchDomain?: ListLookupFilesSearchDomainEnum;
}

export interface NgsiemApiListParsersRequest {
    limit?: string;
    offset?: string;
    filter?: string;
    repository?: ListParsersRepositoryEnum;
}

export interface NgsiemApiListSavedQueriesRequest {
    limit?: string;
    offset?: string;
    filter?: string;
    searchDomain?: ListSavedQueriesSearchDomainEnum;
}

export interface NgsiemApiStartSearchV1Request {
    repository: string;
    body: ApiQueryJobInput;
}

export interface NgsiemApiStopSearchV1Request {
    repository: string;
    id: string;
}

export interface NgsiemApiUpdateDashboardFromTemplateRequest {
    searchDomain?: UpdateDashboardFromTemplateSearchDomainEnum;
    ids?: string;
    yamlTemplate?: Blob;
}

export interface NgsiemApiUpdateLookupFileRequest {
    searchDomain?: UpdateLookupFileSearchDomainEnum;
    filename?: string;
    file?: Blob;
}

export interface NgsiemApiUpdateLookupFileEntriesRequest {
    searchDomain?: UpdateLookupFileEntriesSearchDomainEnum;
    filename?: string;
    file?: Blob;
    updateMode?: UpdateLookupFileEntriesUpdateModeEnum;
    keyColumns?: string;
    ignoreCase?: UpdateLookupFileEntriesIgnoreCaseEnum;
}

export interface NgsiemApiUpdateParserRequest {
    body: ApiUpdateParserRequestV1;
}

export interface NgsiemApiUpdateParserFromTemplateRequest {
    repository?: UpdateParserFromTemplateRepositoryEnum;
    ids?: string;
    yamlTemplate?: Blob;
}

export interface NgsiemApiUpdateSavedQueryFromTemplateRequest {
    searchDomain?: UpdateSavedQueryFromTemplateSearchDomainEnum;
    ids?: string;
    yamlTemplate?: Blob;
}

export interface NgsiemApiUploadLookupV1Request {
    repository: string;
    file: Blob;
}

/**
 *
 */
export class NgsiemApi extends runtime.BaseAPI {
    /**
     * Create Dashboard from LogScale YAML Template in NGSIEM
     */
    async createDashboardFromTemplateRaw(
        requestParameters: NgsiemApiCreateDashboardFromTemplateRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiCreateDashboardFromTemplateResponseV1>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-dashboards:write"]);
        }

        const consumes: runtime.Consume[] = [{ contentType: "multipart/form-data" }];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters["searchDomain"] != null) {
            formParams.append("search_domain", requestParameters["searchDomain"] as any);
        }

        if (requestParameters["name"] != null) {
            formParams.append("name", requestParameters["name"] as any);
        }

        if (requestParameters["yamlTemplate"] != null) {
            formParams.append("yaml_template", requestParameters["yamlTemplate"] as any);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/dashboards-template/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiCreateDashboardFromTemplateResponseV1FromJSON(jsonValue));
    }

    /**
     * Create Dashboard from LogScale YAML Template in NGSIEM
     */
    async createDashboardFromTemplate(
        searchDomain?: CreateDashboardFromTemplateSearchDomainEnum,
        name?: string,
        yamlTemplate?: Blob,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ApiCreateDashboardFromTemplateResponseV1> {
        const response = await this.createDashboardFromTemplateRaw({ searchDomain: searchDomain, name: name, yamlTemplate: yamlTemplate }, initOverrides);
        return await response.value();
    }

    /**
     * Create Lookup File in NGSIEM
     */
    async createLookupFileRaw(
        requestParameters: NgsiemApiCreateLookupFileRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiCreateLookupFileResponseV1>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-lookup-files:write"]);
        }

        const consumes: runtime.Consume[] = [{ contentType: "multipart/form-data" }];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters["searchDomain"] != null) {
            formParams.append("search_domain", requestParameters["searchDomain"] as any);
        }

        if (requestParameters["filename"] != null) {
            formParams.append("filename", requestParameters["filename"] as any);
        }

        if (requestParameters["file"] != null) {
            formParams.append("file", requestParameters["file"] as any);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/lookupfiles/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiCreateLookupFileResponseV1FromJSON(jsonValue));
    }

    /**
     * Create Lookup File in NGSIEM
     */
    async createLookupFile(
        searchDomain?: CreateLookupFileSearchDomainEnum,
        filename?: string,
        file?: Blob,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ApiCreateLookupFileResponseV1> {
        const response = await this.createLookupFileRaw({ searchDomain: searchDomain, filename: filename, file: file }, initOverrides);
        return await response.value();
    }

    /**
     * Create Parser in NGSIEM. This endpoint has been deprecated in favour of the POST /entities/parsers-template/v1 API.
     * @deprecated
     */
    async createParserRaw(requestParameters: NgsiemApiCreateParserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiCreateParserResponseV1>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling createParser().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-parsers:write"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/parsers/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: ApiCreateParserRequestV1ToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiCreateParserResponseV1FromJSON(jsonValue));
    }

    /**
     * Create Parser in NGSIEM. This endpoint has been deprecated in favour of the POST /entities/parsers-template/v1 API.
     * @deprecated
     */
    async createParser(body: ApiCreateParserRequestV1, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiCreateParserResponseV1> {
        const response = await this.createParserRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Create Parser from LogScale YAML Template in NGSIEM
     */
    async createParserFromTemplateRaw(
        requestParameters: NgsiemApiCreateParserFromTemplateRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiCreateParserFromTemplateResponseV1>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-parsers:write"]);
        }

        const consumes: runtime.Consume[] = [{ contentType: "multipart/form-data" }];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters["repository"] != null) {
            formParams.append("repository", requestParameters["repository"] as any);
        }

        if (requestParameters["yamlTemplate"] != null) {
            formParams.append("yaml_template", requestParameters["yamlTemplate"] as any);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/parsers-template/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiCreateParserFromTemplateResponseV1FromJSON(jsonValue));
    }

    /**
     * Create Parser from LogScale YAML Template in NGSIEM
     */
    async createParserFromTemplate(
        repository?: CreateParserFromTemplateRepositoryEnum,
        yamlTemplate?: Blob,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ApiCreateParserFromTemplateResponseV1> {
        const response = await this.createParserFromTemplateRaw({ repository: repository, yamlTemplate: yamlTemplate }, initOverrides);
        return await response.value();
    }

    /**
     * Create Saved Query from LogScale YAML Template in NGSIEM
     */
    async createSavedQueryRaw(
        requestParameters: NgsiemApiCreateSavedQueryRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiCreateSavedQueryResponseV1>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-saved-queries:write"]);
        }

        const consumes: runtime.Consume[] = [{ contentType: "multipart/form-data" }];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters["searchDomain"] != null) {
            formParams.append("search_domain", requestParameters["searchDomain"] as any);
        }

        if (requestParameters["yamlTemplate"] != null) {
            formParams.append("yaml_template", requestParameters["yamlTemplate"] as any);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/savedqueries-template/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiCreateSavedQueryResponseV1FromJSON(jsonValue));
    }

    /**
     * Create Saved Query from LogScale YAML Template in NGSIEM
     */
    async createSavedQuery(searchDomain?: CreateSavedQuerySearchDomainEnum, yamlTemplate?: Blob, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiCreateSavedQueryResponseV1> {
        const response = await this.createSavedQueryRaw({ searchDomain: searchDomain, yamlTemplate: yamlTemplate }, initOverrides);
        return await response.value();
    }

    /**
     * Delete Dashboard in NGSIEM
     */
    async deleteDashboardRaw(
        requestParameters: NgsiemApiDeleteDashboardRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiDeleteDashboardResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        if (requestParameters["searchDomain"] != null) {
            queryParameters["search_domain"] = requestParameters["searchDomain"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-dashboards:write"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/dashboards/v1`,
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiDeleteDashboardResponseV1FromJSON(jsonValue));
    }

    /**
     * Delete Dashboard in NGSIEM
     */
    async deleteDashboard(ids?: string, searchDomain?: DeleteDashboardSearchDomainEnum, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiDeleteDashboardResponseV1> {
        const response = await this.deleteDashboardRaw({ ids: ids, searchDomain: searchDomain }, initOverrides);
        return await response.value();
    }

    /**
     * Delete Lookup File in NGSIEM
     */
    async deleteLookupFileRaw(
        requestParameters: NgsiemApiDeleteLookupFileRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiDeleteLookupFileResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["filename"] != null) {
            queryParameters["filename"] = requestParameters["filename"];
        }

        if (requestParameters["searchDomain"] != null) {
            queryParameters["search_domain"] = requestParameters["searchDomain"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-lookup-files:write"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/lookupfiles/v1`,
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiDeleteLookupFileResponseV1FromJSON(jsonValue));
    }

    /**
     * Delete Lookup File in NGSIEM
     */
    async deleteLookupFile(filename?: string, searchDomain?: DeleteLookupFileSearchDomainEnum, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiDeleteLookupFileResponseV1> {
        const response = await this.deleteLookupFileRaw({ filename: filename, searchDomain: searchDomain }, initOverrides);
        return await response.value();
    }

    /**
     * Delete Parser in NGSIEM
     */
    async deleteParserRaw(requestParameters: NgsiemApiDeleteParserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiDeleteParserResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        if (requestParameters["repository"] != null) {
            queryParameters["repository"] = requestParameters["repository"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-parsers:write"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/parsers/v1`,
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiDeleteParserResponseV1FromJSON(jsonValue));
    }

    /**
     * Delete Parser in NGSIEM
     */
    async deleteParser(ids?: string, repository?: DeleteParserRepositoryEnum, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiDeleteParserResponseV1> {
        const response = await this.deleteParserRaw({ ids: ids, repository: repository }, initOverrides);
        return await response.value();
    }

    /**
     * Delete Saved Query in NGSIEM
     */
    async deleteSavedQueryRaw(
        requestParameters: NgsiemApiDeleteSavedQueryRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiDeleteSavedQueryResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        if (requestParameters["searchDomain"] != null) {
            queryParameters["search_domain"] = requestParameters["searchDomain"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-saved-queries:write"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/savedqueries/v1`,
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiDeleteSavedQueryResponseV1FromJSON(jsonValue));
    }

    /**
     * Delete Saved Query in NGSIEM
     */
    async deleteSavedQuery(ids?: string, searchDomain?: DeleteSavedQuerySearchDomainEnum, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiDeleteSavedQueryResponseV1> {
        const response = await this.deleteSavedQueryRaw({ ids: ids, searchDomain: searchDomain }, initOverrides);
        return await response.value();
    }

    /**
     * Create a new data connection
     */
    async externalCreateDataConnectionRaw(
        requestParameters: NgsiemApiExternalCreateDataConnectionRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DataconnectionmanagementGenericResourcesResponse>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling externalCreateDataConnection().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-data-connections:write"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem/entities/connections/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: DataconnectionmanagementCreateDataConnectionRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DataconnectionmanagementGenericResourcesResponseFromJSON(jsonValue));
    }

    /**
     * Create a new data connection
     */
    async externalCreateDataConnection(
        body: DataconnectionmanagementCreateDataConnectionRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DataconnectionmanagementGenericResourcesResponse> {
        const response = await this.externalCreateDataConnectionRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Delete a data connection
     */
    async externalDeleteDataConnectionRaw(
        requestParameters: NgsiemApiExternalDeleteDataConnectionRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<MsaReplyAffectedEntities>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling externalDeleteDataConnection().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-data-connections:write"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem/entities/connections/v1`,
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaReplyAffectedEntitiesFromJSON(jsonValue));
    }

    /**
     * Delete a data connection
     */
    async externalDeleteDataConnection(ids: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MsaReplyAffectedEntities> {
        const response = await this.externalDeleteDataConnectionRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Get data connection by ID
     */
    async externalGetDataConnectionByIDRaw(
        requestParameters: NgsiemApiExternalGetDataConnectionByIDRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DataconnectionmanagementDataConnectionResponse>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling externalGetDataConnectionByID().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-data-connections:read"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem/entities/connections/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DataconnectionmanagementDataConnectionResponseFromJSON(jsonValue));
    }

    /**
     * Get data connection by ID
     */
    async externalGetDataConnectionByID(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DataconnectionmanagementDataConnectionResponse> {
        const response = await this.externalGetDataConnectionByIDRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Get data connection provisioning status
     */
    async externalGetDataConnectionStatusRaw(
        requestParameters: NgsiemApiExternalGetDataConnectionStatusRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DataconnectionmanagementConnectionStatusResponse>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling externalGetDataConnectionStatus().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"]!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-data-connections:read"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem/entities/connections/status/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DataconnectionmanagementConnectionStatusResponseFromJSON(jsonValue));
    }

    /**
     * Get data connection provisioning status
     */
    async externalGetDataConnectionStatus(ids: Array<string>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DataconnectionmanagementConnectionStatusResponse> {
        const response = await this.externalGetDataConnectionStatusRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Get Ingest token for data connection
     */
    async externalGetDataConnectionTokenRaw(
        requestParameters: NgsiemApiExternalGetDataConnectionTokenRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DataconnectionmanagementConnectionTokenResponse>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling externalGetDataConnectionToken().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-data-connections:read"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem/entities/connections/token/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DataconnectionmanagementConnectionTokenResponseFromJSON(jsonValue));
    }

    /**
     * Get Ingest token for data connection
     */
    async externalGetDataConnectionToken(ids: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DataconnectionmanagementConnectionTokenResponse> {
        const response = await this.externalGetDataConnectionTokenRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * List configurations for a data connector
     */
    async externalListConnectorConfigsRaw(
        requestParameters: NgsiemApiExternalListConnectorConfigsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DataconnectionmanagementConfigResponse>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling externalListConnectorConfigs().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-data-connections:read"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem/entities/connectors/configs/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DataconnectionmanagementConfigResponseFromJSON(jsonValue));
    }

    /**
     * List configurations for a data connector
     */
    async externalListConnectorConfigs(ids: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DataconnectionmanagementConfigResponse> {
        const response = await this.externalListConnectorConfigsRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * List and search data connections
     */
    async externalListDataConnectionsRaw(
        requestParameters: NgsiemApiExternalListDataConnectionsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DataconnectionmanagementDataConnectionResponse>> {
        const queryParameters: any = {};

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-data-connections:read"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem/combined/connections/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DataconnectionmanagementDataConnectionResponseFromJSON(jsonValue));
    }

    /**
     * List and search data connections
     */
    async externalListDataConnections(
        filter?: string,
        offset?: number,
        limit?: number,
        sort?: string,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DataconnectionmanagementDataConnectionResponse> {
        const response = await this.externalListDataConnectionsRaw({ filter: filter, offset: offset, limit: limit, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * List available data connectors
     */
    async externalListDataConnectorsRaw(
        requestParameters: NgsiemApiExternalListDataConnectorsRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DataconnectionmanagementDataConnectorResponse>> {
        const queryParameters: any = {};

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["sort"] != null) {
            queryParameters["sort"] = requestParameters["sort"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-data-connections:read"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem/combined/connectors/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DataconnectionmanagementDataConnectorResponseFromJSON(jsonValue));
    }

    /**
     * List available data connectors
     */
    async externalListDataConnectors(
        filter?: string,
        offset?: number,
        limit?: number,
        sort?: string,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DataconnectionmanagementDataConnectorResponse> {
        const response = await this.externalListDataConnectorsRaw({ filter: filter, offset: offset, limit: limit, sort: sort }, initOverrides);
        return await response.value();
    }

    /**
     * Regenerate Ingest token for data connection
     */
    async externalRegenerateDataConnectionTokenRaw(
        requestParameters: NgsiemApiExternalRegenerateDataConnectionTokenRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DataconnectionmanagementConnectionTokenResponse>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling externalRegenerateDataConnectionToken().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-data-connections:write"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem/entities/connections/token/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DataconnectionmanagementConnectionTokenResponseFromJSON(jsonValue));
    }

    /**
     * Regenerate Ingest token for data connection
     */
    async externalRegenerateDataConnectionToken(ids: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DataconnectionmanagementConnectionTokenResponse> {
        const response = await this.externalRegenerateDataConnectionTokenRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Update a data connection
     */
    async externalUpdateDataConnectionRaw(
        requestParameters: NgsiemApiExternalUpdateDataConnectionRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<MsaReplyAffectedEntities>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling externalUpdateDataConnection().');
        }

        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling externalUpdateDataConnection().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-data-connections:write"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem/entities/connections/v1`,
                method: "PATCH",
                headers: headerParameters,
                query: queryParameters,
                body: DataconnectionmanagementUpdateDataConnectionRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaReplyAffectedEntitiesFromJSON(jsonValue));
    }

    /**
     * Update a data connection
     */
    async externalUpdateDataConnection(
        ids: string,
        body: DataconnectionmanagementUpdateDataConnectionRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<MsaReplyAffectedEntities> {
        const response = await this.externalUpdateDataConnectionRaw({ ids: ids, body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Update data connection status
     */
    async externalUpdateDataConnectionStatusRaw(
        requestParameters: NgsiemApiExternalUpdateDataConnectionStatusRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<DataconnectionmanagementConnectionStatusResponse>> {
        if (requestParameters["ids"] == null) {
            throw new runtime.RequiredError("ids", 'Required parameter "ids" was null or undefined when calling externalUpdateDataConnectionStatus().');
        }

        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling externalUpdateDataConnectionStatus().');
        }

        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-data-connections:write"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem/entities/connections/status/v1`,
                method: "PATCH",
                headers: headerParameters,
                query: queryParameters,
                body: DataconnectionmanagementUpdateDataConnectionStatusRequestToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DataconnectionmanagementConnectionStatusResponseFromJSON(jsonValue));
    }

    /**
     * Update data connection status
     */
    async externalUpdateDataConnectionStatus(
        ids: string,
        body: DataconnectionmanagementUpdateDataConnectionStatusRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<DataconnectionmanagementConnectionStatusResponse> {
        const response = await this.externalUpdateDataConnectionStatusRaw({ ids: ids, body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve Dashboard in NGSIEM as LogScale YAML Template
     */
    async getDashboardTemplateRaw(
        requestParameters: NgsiemApiGetDashboardTemplateRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiGetDashboardTemplateResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        if (requestParameters["searchDomain"] != null) {
            queryParameters["search_domain"] = requestParameters["searchDomain"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-dashboards:read"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/dashboards-template/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiGetDashboardTemplateResponseV1FromJSON(jsonValue));
    }

    /**
     * Retrieve Dashboard in NGSIEM as LogScale YAML Template
     */
    async getDashboardTemplate(
        ids?: string,
        searchDomain?: GetDashboardTemplateSearchDomainEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ApiGetDashboardTemplateResponseV1> {
        const response = await this.getDashboardTemplateRaw({ ids: ids, searchDomain: searchDomain }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve Lookup File in NGSIEM
     */
    async getLookupFileRaw(requestParameters: NgsiemApiGetLookupFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters["filename"] != null) {
            queryParameters["filename"] = requestParameters["filename"];
        }

        if (requestParameters["searchDomain"] != null) {
            queryParameters["search_domain"] = requestParameters["searchDomain"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-lookup-files:read"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/lookupfiles/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieve Lookup File in NGSIEM
     */
    async getLookupFile(filename?: string, searchDomain?: GetLookupFileSearchDomainEnum, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getLookupFileRaw({ filename: filename, searchDomain: searchDomain }, initOverrides);
    }

    /**
     * Download lookup file in package from NGSIEM
     */
    async getLookupFromPackageV1Raw(requestParameters: NgsiemApiGetLookupFromPackageV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters["repository"] == null) {
            throw new runtime.RequiredError("repository", 'Required parameter "repository" was null or undefined when calling getLookupFromPackageV1().');
        }

        if (requestParameters["_package"] == null) {
            throw new runtime.RequiredError("_package", 'Required parameter "_package" was null or undefined when calling getLookupFromPackageV1().');
        }

        if (requestParameters["filename"] == null) {
            throw new runtime.RequiredError("filename", 'Required parameter "filename" was null or undefined when calling getLookupFromPackageV1().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["humio-auth-proxy:read"]);
        }

        const response = await this.request(
            {
                path: `/humio/api/v1/repositories/{repository}/files/{package}/{filename}`
                    .replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters["repository"])))
                    .replace(`{${"package"}}`, encodeURIComponent(String(requestParameters["_package"])))
                    .replace(`{${"filename"}}`, encodeURIComponent(String(requestParameters["filename"]))),
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Download lookup file in package from NGSIEM
     */
    async getLookupFromPackageV1(repository: string, _package: string, filename: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getLookupFromPackageV1Raw({ repository: repository, _package: _package, filename: filename }, initOverrides);
    }

    /**
     * Download lookup file in namespaced package from NGSIEM
     */
    async getLookupFromPackageWithNamespaceV1Raw(
        requestParameters: NgsiemApiGetLookupFromPackageWithNamespaceV1Request,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters["repository"] == null) {
            throw new runtime.RequiredError("repository", 'Required parameter "repository" was null or undefined when calling getLookupFromPackageWithNamespaceV1().');
        }

        if (requestParameters["namespace"] == null) {
            throw new runtime.RequiredError("namespace", 'Required parameter "namespace" was null or undefined when calling getLookupFromPackageWithNamespaceV1().');
        }

        if (requestParameters["_package"] == null) {
            throw new runtime.RequiredError("_package", 'Required parameter "_package" was null or undefined when calling getLookupFromPackageWithNamespaceV1().');
        }

        if (requestParameters["filename"] == null) {
            throw new runtime.RequiredError("filename", 'Required parameter "filename" was null or undefined when calling getLookupFromPackageWithNamespaceV1().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["humio-auth-proxy:read"]);
        }

        const response = await this.request(
            {
                path: `/humio/api/v1/repositories/{repository}/files/{namespace}/{package}/{filename}`
                    .replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters["repository"])))
                    .replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters["namespace"])))
                    .replace(`{${"package"}}`, encodeURIComponent(String(requestParameters["_package"])))
                    .replace(`{${"filename"}}`, encodeURIComponent(String(requestParameters["filename"]))),
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Download lookup file in namespaced package from NGSIEM
     */
    async getLookupFromPackageWithNamespaceV1(repository: string, namespace: string, _package: string, filename: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getLookupFromPackageWithNamespaceV1Raw({ repository: repository, namespace: namespace, _package: _package, filename: filename }, initOverrides);
    }

    /**
     * Download lookup file from NGSIEM
     */
    async getLookupV1Raw(requestParameters: NgsiemApiGetLookupV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters["repository"] == null) {
            throw new runtime.RequiredError("repository", 'Required parameter "repository" was null or undefined when calling getLookupV1().');
        }

        if (requestParameters["filename"] == null) {
            throw new runtime.RequiredError("filename", 'Required parameter "filename" was null or undefined when calling getLookupV1().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["humio-auth-proxy:read"]);
        }

        const response = await this.request(
            {
                path: `/humio/api/v1/repositories/{repository}/files/{filename}`
                    .replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters["repository"])))
                    .replace(`{${"filename"}}`, encodeURIComponent(String(requestParameters["filename"]))),
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Download lookup file from NGSIEM
     */
    async getLookupV1(repository: string, filename: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getLookupV1Raw({ repository: repository, filename: filename }, initOverrides);
    }

    /**
     * Retrieve Parser in NGSIEM. This endpoint has been deprecated in favour of the GET /entities/parsers-template/v1 API.
     * @deprecated
     */
    async getParserRaw(requestParameters: NgsiemApiGetParserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiGetParserResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        if (requestParameters["repository"] != null) {
            queryParameters["repository"] = requestParameters["repository"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-parsers:read"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/parsers/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiGetParserResponseV1FromJSON(jsonValue));
    }

    /**
     * Retrieve Parser in NGSIEM. This endpoint has been deprecated in favour of the GET /entities/parsers-template/v1 API.
     * @deprecated
     */
    async getParser(ids?: string, repository?: GetParserRepositoryEnum, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiGetParserResponseV1> {
        const response = await this.getParserRaw({ ids: ids, repository: repository }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve Parser in NGSIEM as LogScale YAML Template
     */
    async getParserTemplateRaw(
        requestParameters: NgsiemApiGetParserTemplateRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiGetParserTemplateResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        if (requestParameters["repository"] != null) {
            queryParameters["repository"] = requestParameters["repository"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-parsers:read"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/parsers-template/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiGetParserTemplateResponseV1FromJSON(jsonValue));
    }

    /**
     * Retrieve Parser in NGSIEM as LogScale YAML Template
     */
    async getParserTemplate(ids?: string, repository?: GetParserTemplateRepositoryEnum, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiGetParserTemplateResponseV1> {
        const response = await this.getParserTemplateRaw({ ids: ids, repository: repository }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve Saved Query in NGSIEM as LogScale YAML Template
     */
    async getSavedQueryTemplateRaw(
        requestParameters: NgsiemApiGetSavedQueryTemplateRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiGetSavedQueryResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["ids"] != null) {
            queryParameters["ids"] = requestParameters["ids"];
        }

        if (requestParameters["searchDomain"] != null) {
            queryParameters["search_domain"] = requestParameters["searchDomain"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-saved-queries:read"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/savedqueries-template/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiGetSavedQueryResponseV1FromJSON(jsonValue));
    }

    /**
     * Retrieve Saved Query in NGSIEM as LogScale YAML Template
     */
    async getSavedQueryTemplate(ids?: string, searchDomain?: GetSavedQueryTemplateSearchDomainEnum, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiGetSavedQueryResponseV1> {
        const response = await this.getSavedQueryTemplateRaw({ ids: ids, searchDomain: searchDomain }, initOverrides);
        return await response.value();
    }

    /**
     * Get status of search
     */
    async getSearchStatusV1Raw(requestParameters: NgsiemApiGetSearchStatusV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiQueryJobsResults>> {
        if (requestParameters["repository"] == null) {
            throw new runtime.RequiredError("repository", 'Required parameter "repository" was null or undefined when calling getSearchStatusV1().');
        }

        if (requestParameters["id"] == null) {
            throw new runtime.RequiredError("id", 'Required parameter "id" was null or undefined when calling getSearchStatusV1().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["humio-auth-proxy:read"]);
        }

        const response = await this.request(
            {
                path: `/humio/api/v1/repositories/{repository}/queryjobs/{id}`
                    .replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters["repository"])))
                    .replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiQueryJobsResultsFromJSON(jsonValue));
    }

    /**
     * Get status of search
     */
    async getSearchStatusV1(repository: string, id: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiQueryJobsResults> {
        const response = await this.getSearchStatusV1Raw({ repository: repository, id: id }, initOverrides);
        return await response.value();
    }

    /**
     * List Dashboards in NGSIEM
     */
    async listDashboardsRaw(requestParameters: NgsiemApiListDashboardsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiListDashboardsResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["searchDomain"] != null) {
            queryParameters["search_domain"] = requestParameters["searchDomain"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-dashboards:read"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/queries/dashboards/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiListDashboardsResponseV1FromJSON(jsonValue));
    }

    /**
     * List Dashboards in NGSIEM
     */
    async listDashboards(
        limit?: string,
        offset?: string,
        filter?: string,
        searchDomain?: ListDashboardsSearchDomainEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ApiListDashboardsResponseV1> {
        const response = await this.listDashboardsRaw({ limit: limit, offset: offset, filter: filter, searchDomain: searchDomain }, initOverrides);
        return await response.value();
    }

    /**
     * List Lookup Files in NGSIEM
     */
    async listLookupFilesRaw(
        requestParameters: NgsiemApiListLookupFilesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiListLookupFilesResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["searchDomain"] != null) {
            queryParameters["search_domain"] = requestParameters["searchDomain"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-lookup-files:read"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/queries/lookupfiles/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiListLookupFilesResponseV1FromJSON(jsonValue));
    }

    /**
     * List Lookup Files in NGSIEM
     */
    async listLookupFiles(
        limit?: string,
        offset?: string,
        filter?: string,
        searchDomain?: ListLookupFilesSearchDomainEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ApiListLookupFilesResponseV1> {
        const response = await this.listLookupFilesRaw({ limit: limit, offset: offset, filter: filter, searchDomain: searchDomain }, initOverrides);
        return await response.value();
    }

    /**
     * List Parsers in NGSIEM
     */
    async listParsersRaw(requestParameters: NgsiemApiListParsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiListParsersResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["repository"] != null) {
            queryParameters["repository"] = requestParameters["repository"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-parsers:read"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/queries/parsers/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiListParsersResponseV1FromJSON(jsonValue));
    }

    /**
     * List Parsers in NGSIEM
     */
    async listParsers(
        limit?: string,
        offset?: string,
        filter?: string,
        repository?: ListParsersRepositoryEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ApiListParsersResponseV1> {
        const response = await this.listParsersRaw({ limit: limit, offset: offset, filter: filter, repository: repository }, initOverrides);
        return await response.value();
    }

    /**
     * Get Saved Queries in NGSIEM
     */
    async listSavedQueriesRaw(
        requestParameters: NgsiemApiListSavedQueriesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiListSavedQueriesResponseV1>> {
        const queryParameters: any = {};

        if (requestParameters["limit"] != null) {
            queryParameters["limit"] = requestParameters["limit"];
        }

        if (requestParameters["offset"] != null) {
            queryParameters["offset"] = requestParameters["offset"];
        }

        if (requestParameters["filter"] != null) {
            queryParameters["filter"] = requestParameters["filter"];
        }

        if (requestParameters["searchDomain"] != null) {
            queryParameters["search_domain"] = requestParameters["searchDomain"];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-saved-queries:read"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/queries/savedqueries/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiListSavedQueriesResponseV1FromJSON(jsonValue));
    }

    /**
     * Get Saved Queries in NGSIEM
     */
    async listSavedQueries(
        limit?: string,
        offset?: string,
        filter?: string,
        searchDomain?: ListSavedQueriesSearchDomainEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ApiListSavedQueriesResponseV1> {
        const response = await this.listSavedQueriesRaw({ limit: limit, offset: offset, filter: filter, searchDomain: searchDomain }, initOverrides);
        return await response.value();
    }

    /**
     * Initiate search
     */
    async startSearchV1Raw(requestParameters: NgsiemApiStartSearchV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiQueryJobResponse>> {
        if (requestParameters["repository"] == null) {
            throw new runtime.RequiredError("repository", 'Required parameter "repository" was null or undefined when calling startSearchV1().');
        }

        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling startSearchV1().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["humio-auth-proxy:write"]);
        }

        const response = await this.request(
            {
                path: `/humio/api/v1/repositories/{repository}/queryjobs`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters["repository"]))),
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: ApiQueryJobInputToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiQueryJobResponseFromJSON(jsonValue));
    }

    /**
     * Initiate search
     */
    async startSearchV1(repository: string, body: ApiQueryJobInput, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiQueryJobResponse> {
        const response = await this.startSearchV1Raw({ repository: repository, body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Stop search
     */
    async stopSearchV1Raw(requestParameters: NgsiemApiStopSearchV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters["repository"] == null) {
            throw new runtime.RequiredError("repository", 'Required parameter "repository" was null or undefined when calling stopSearchV1().');
        }

        if (requestParameters["id"] == null) {
            throw new runtime.RequiredError("id", 'Required parameter "id" was null or undefined when calling stopSearchV1().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["humio-auth-proxy:write"]);
        }

        const response = await this.request(
            {
                path: `/humio/api/v1/repositories/{repository}/queryjobs/{id}`
                    .replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters["repository"])))
                    .replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Stop search
     */
    async stopSearchV1(repository: string, id: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.stopSearchV1Raw({ repository: repository, id: id }, initOverrides);
    }

    /**
     * Update Dashboard from LogScale YAML Template in NGSIEM.
     */
    async updateDashboardFromTemplateRaw(
        requestParameters: NgsiemApiUpdateDashboardFromTemplateRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiUpdateDashboardFromTemplateResponseV1>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-dashboards:write"]);
        }

        const consumes: runtime.Consume[] = [{ contentType: "multipart/form-data" }];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters["searchDomain"] != null) {
            formParams.append("search_domain", requestParameters["searchDomain"] as any);
        }

        if (requestParameters["ids"] != null) {
            formParams.append("ids", requestParameters["ids"] as any);
        }

        if (requestParameters["yamlTemplate"] != null) {
            formParams.append("yaml_template", requestParameters["yamlTemplate"] as any);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/dashboards-template/v1`,
                method: "PATCH",
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiUpdateDashboardFromTemplateResponseV1FromJSON(jsonValue));
    }

    /**
     * Update Dashboard from LogScale YAML Template in NGSIEM.
     */
    async updateDashboardFromTemplate(
        searchDomain?: UpdateDashboardFromTemplateSearchDomainEnum,
        ids?: string,
        yamlTemplate?: Blob,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ApiUpdateDashboardFromTemplateResponseV1> {
        const response = await this.updateDashboardFromTemplateRaw({ searchDomain: searchDomain, ids: ids, yamlTemplate: yamlTemplate }, initOverrides);
        return await response.value();
    }

    /**
     * Update an entire Lookup File in NGSIEM
     */
    async updateLookupFileRaw(
        requestParameters: NgsiemApiUpdateLookupFileRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiUpdateLookupFileResponseV1>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-lookup-files:write"]);
        }

        const consumes: runtime.Consume[] = [{ contentType: "multipart/form-data" }];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters["searchDomain"] != null) {
            formParams.append("search_domain", requestParameters["searchDomain"] as any);
        }

        if (requestParameters["filename"] != null) {
            formParams.append("filename", requestParameters["filename"] as any);
        }

        if (requestParameters["file"] != null) {
            formParams.append("file", requestParameters["file"] as any);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/lookupfiles/v1`,
                method: "PATCH",
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiUpdateLookupFileResponseV1FromJSON(jsonValue));
    }

    /**
     * Update an entire Lookup File in NGSIEM
     */
    async updateLookupFile(
        searchDomain?: UpdateLookupFileSearchDomainEnum,
        filename?: string,
        file?: Blob,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ApiUpdateLookupFileResponseV1> {
        const response = await this.updateLookupFileRaw({ searchDomain: searchDomain, filename: filename, file: file }, initOverrides);
        return await response.value();
    }

    /**
     * Update entries in an existing Lookup File in NGSIEM
     */
    async updateLookupFileEntriesRaw(
        requestParameters: NgsiemApiUpdateLookupFileEntriesRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiUpdateLookupFileEntriesResponseV1>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-lookup-files:write"]);
        }

        const consumes: runtime.Consume[] = [{ contentType: "multipart/form-data" }];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters["searchDomain"] != null) {
            formParams.append("search_domain", requestParameters["searchDomain"] as any);
        }

        if (requestParameters["filename"] != null) {
            formParams.append("filename", requestParameters["filename"] as any);
        }

        if (requestParameters["file"] != null) {
            formParams.append("file", requestParameters["file"] as any);
        }

        if (requestParameters["updateMode"] != null) {
            formParams.append("update_mode", requestParameters["updateMode"] as any);
        }

        if (requestParameters["keyColumns"] != null) {
            formParams.append("key_columns", requestParameters["keyColumns"] as any);
        }

        if (requestParameters["ignoreCase"] != null) {
            formParams.append("ignore_case", requestParameters["ignoreCase"] as any);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/lookupfiles-entries/v1`,
                method: "PATCH",
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiUpdateLookupFileEntriesResponseV1FromJSON(jsonValue));
    }

    /**
     * Update entries in an existing Lookup File in NGSIEM
     */
    async updateLookupFileEntries(
        searchDomain?: UpdateLookupFileEntriesSearchDomainEnum,
        filename?: string,
        file?: Blob,
        updateMode?: UpdateLookupFileEntriesUpdateModeEnum,
        keyColumns?: string,
        ignoreCase?: UpdateLookupFileEntriesIgnoreCaseEnum,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ApiUpdateLookupFileEntriesResponseV1> {
        const response = await this.updateLookupFileEntriesRaw(
            { searchDomain: searchDomain, filename: filename, file: file, updateMode: updateMode, keyColumns: keyColumns, ignoreCase: ignoreCase },
            initOverrides,
        );
        return await response.value();
    }

    /**
     * Update Parser in NGSIEM. Please note that name changes are not supported, but rather should be created as a new parser.  This endpoint has been deprecated in favour of the PATCH /entities/parsers-template/v1 API.
     * @deprecated
     */
    async updateParserRaw(requestParameters: NgsiemApiUpdateParserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiUpdateParserResponseV1>> {
        if (requestParameters["body"] == null) {
            throw new runtime.RequiredError("body", 'Required parameter "body" was null or undefined when calling updateParser().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-parsers:write"]);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/parsers/v1`,
                method: "PATCH",
                headers: headerParameters,
                query: queryParameters,
                body: ApiUpdateParserRequestV1ToJSON(requestParameters["body"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiUpdateParserResponseV1FromJSON(jsonValue));
    }

    /**
     * Update Parser in NGSIEM. Please note that name changes are not supported, but rather should be created as a new parser.  This endpoint has been deprecated in favour of the PATCH /entities/parsers-template/v1 API.
     * @deprecated
     */
    async updateParser(body: ApiUpdateParserRequestV1, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiUpdateParserResponseV1> {
        const response = await this.updateParserRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Update Parser in NGSIEM from YAML Template. Please note that name changes are not supported, but rather should be created as a new parser.
     */
    async updateParserFromTemplateRaw(
        requestParameters: NgsiemApiUpdateParserFromTemplateRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiUpdateParserFromTemplateResponseV1>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-parsers:write"]);
        }

        const consumes: runtime.Consume[] = [{ contentType: "multipart/form-data" }];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters["repository"] != null) {
            formParams.append("repository", requestParameters["repository"] as any);
        }

        if (requestParameters["ids"] != null) {
            formParams.append("ids", requestParameters["ids"] as any);
        }

        if (requestParameters["yamlTemplate"] != null) {
            formParams.append("yaml_template", requestParameters["yamlTemplate"] as any);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/parsers-template/v1`,
                method: "PATCH",
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiUpdateParserFromTemplateResponseV1FromJSON(jsonValue));
    }

    /**
     * Update Parser in NGSIEM from YAML Template. Please note that name changes are not supported, but rather should be created as a new parser.
     */
    async updateParserFromTemplate(
        repository?: UpdateParserFromTemplateRepositoryEnum,
        ids?: string,
        yamlTemplate?: Blob,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ApiUpdateParserFromTemplateResponseV1> {
        const response = await this.updateParserFromTemplateRaw({ repository: repository, ids: ids, yamlTemplate: yamlTemplate }, initOverrides);
        return await response.value();
    }

    /**
     * Update Saved Query from LogScale YAML Template in NGSIEM.
     */
    async updateSavedQueryFromTemplateRaw(
        requestParameters: NgsiemApiUpdateSavedQueryFromTemplateRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ApiUpdateSavedQueryResponseV1>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["ngsiem-saved-queries:write"]);
        }

        const consumes: runtime.Consume[] = [{ contentType: "multipart/form-data" }];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters["searchDomain"] != null) {
            formParams.append("search_domain", requestParameters["searchDomain"] as any);
        }

        if (requestParameters["ids"] != null) {
            formParams.append("ids", requestParameters["ids"] as any);
        }

        if (requestParameters["yamlTemplate"] != null) {
            formParams.append("yaml_template", requestParameters["yamlTemplate"] as any);
        }

        const response = await this.request(
            {
                path: `/ngsiem-content/entities/savedqueries-template/v1`,
                method: "PATCH",
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiUpdateSavedQueryResponseV1FromJSON(jsonValue));
    }

    /**
     * Update Saved Query from LogScale YAML Template in NGSIEM.
     */
    async updateSavedQueryFromTemplate(
        searchDomain?: UpdateSavedQueryFromTemplateSearchDomainEnum,
        ids?: string,
        yamlTemplate?: Blob,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ApiUpdateSavedQueryResponseV1> {
        const response = await this.updateSavedQueryFromTemplateRaw({ searchDomain: searchDomain, ids: ids, yamlTemplate: yamlTemplate }, initOverrides);
        return await response.value();
    }

    /**
     * Upload file to NGSIEM
     */
    async uploadLookupV1Raw(requestParameters: NgsiemApiUploadLookupV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters["repository"] == null) {
            throw new runtime.RequiredError("repository", 'Required parameter "repository" was null or undefined when calling uploadLookupV1().');
        }

        if (requestParameters["file"] == null) {
            throw new runtime.RequiredError("file", 'Required parameter "file" was null or undefined when calling uploadLookupV1().');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["humio-auth-proxy:write"]);
        }

        const consumes: runtime.Consume[] = [{ contentType: "multipart/form-data" }];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters["file"] != null) {
            formParams.append("file", requestParameters["file"] as any);
        }

        const response = await this.request(
            {
                path: `/humio/api/v1/repositories/{repository}/files`.replace(`{${"repository"}}`, encodeURIComponent(String(requestParameters["repository"]))),
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            },
            initOverrides,
        );

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Upload file to NGSIEM
     */
    async uploadLookupV1(repository: string, file: Blob, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.uploadLookupV1Raw({ repository: repository, file: file }, initOverrides);
    }
}

/**
 * @export
 */
export const CreateDashboardFromTemplateSearchDomainEnum = {
    All: "all",
    Falcon: "falcon",
    ThirdParty: "third-party",
} as const;
export type CreateDashboardFromTemplateSearchDomainEnum = (typeof CreateDashboardFromTemplateSearchDomainEnum)[keyof typeof CreateDashboardFromTemplateSearchDomainEnum];
/**
 * @export
 */
export const CreateLookupFileSearchDomainEnum = {
    All: "all",
    Falcon: "falcon",
    ThirdParty: "third-party",
    ParsersRepository: "parsers-repository",
} as const;
export type CreateLookupFileSearchDomainEnum = (typeof CreateLookupFileSearchDomainEnum)[keyof typeof CreateLookupFileSearchDomainEnum];
/**
 * @export
 */
export const CreateParserFromTemplateRepositoryEnum = {
    ParsersRepository: "parsers-repository",
} as const;
export type CreateParserFromTemplateRepositoryEnum = (typeof CreateParserFromTemplateRepositoryEnum)[keyof typeof CreateParserFromTemplateRepositoryEnum];
/**
 * @export
 */
export const CreateSavedQuerySearchDomainEnum = {
    All: "all",
    Falcon: "falcon",
    ThirdParty: "third-party",
} as const;
export type CreateSavedQuerySearchDomainEnum = (typeof CreateSavedQuerySearchDomainEnum)[keyof typeof CreateSavedQuerySearchDomainEnum];
/**
 * @export
 */
export const DeleteDashboardSearchDomainEnum = {
    All: "all",
    Falcon: "falcon",
    ThirdParty: "third-party",
} as const;
export type DeleteDashboardSearchDomainEnum = (typeof DeleteDashboardSearchDomainEnum)[keyof typeof DeleteDashboardSearchDomainEnum];
/**
 * @export
 */
export const DeleteLookupFileSearchDomainEnum = {
    All: "all",
    Falcon: "falcon",
    ThirdParty: "third-party",
    ParsersRepository: "parsers-repository",
} as const;
export type DeleteLookupFileSearchDomainEnum = (typeof DeleteLookupFileSearchDomainEnum)[keyof typeof DeleteLookupFileSearchDomainEnum];
/**
 * @export
 */
export const DeleteParserRepositoryEnum = {
    ParsersRepository: "parsers-repository",
} as const;
export type DeleteParserRepositoryEnum = (typeof DeleteParserRepositoryEnum)[keyof typeof DeleteParserRepositoryEnum];
/**
 * @export
 */
export const DeleteSavedQuerySearchDomainEnum = {
    All: "all",
    Falcon: "falcon",
    ThirdParty: "third-party",
} as const;
export type DeleteSavedQuerySearchDomainEnum = (typeof DeleteSavedQuerySearchDomainEnum)[keyof typeof DeleteSavedQuerySearchDomainEnum];
/**
 * @export
 */
export const GetDashboardTemplateSearchDomainEnum = {
    All: "all",
    Falcon: "falcon",
    ThirdParty: "third-party",
    Dashboards: "dashboards",
} as const;
export type GetDashboardTemplateSearchDomainEnum = (typeof GetDashboardTemplateSearchDomainEnum)[keyof typeof GetDashboardTemplateSearchDomainEnum];
/**
 * @export
 */
export const GetLookupFileSearchDomainEnum = {
    All: "all",
    Falcon: "falcon",
    ThirdParty: "third-party",
    Dashboards: "dashboards",
    ParsersRepository: "parsers-repository",
} as const;
export type GetLookupFileSearchDomainEnum = (typeof GetLookupFileSearchDomainEnum)[keyof typeof GetLookupFileSearchDomainEnum];
/**
 * @export
 */
export const GetParserRepositoryEnum = {
    ParsersRepository: "parsers-repository",
} as const;
export type GetParserRepositoryEnum = (typeof GetParserRepositoryEnum)[keyof typeof GetParserRepositoryEnum];
/**
 * @export
 */
export const GetParserTemplateRepositoryEnum = {
    ParsersRepository: "parsers-repository",
} as const;
export type GetParserTemplateRepositoryEnum = (typeof GetParserTemplateRepositoryEnum)[keyof typeof GetParserTemplateRepositoryEnum];
/**
 * @export
 */
export const GetSavedQueryTemplateSearchDomainEnum = {
    All: "all",
    Falcon: "falcon",
    ThirdParty: "third-party",
    Dashboards: "dashboards",
} as const;
export type GetSavedQueryTemplateSearchDomainEnum = (typeof GetSavedQueryTemplateSearchDomainEnum)[keyof typeof GetSavedQueryTemplateSearchDomainEnum];
/**
 * @export
 */
export const ListDashboardsSearchDomainEnum = {
    All: "all",
    Falcon: "falcon",
    ThirdParty: "third-party",
    Dashboards: "dashboards",
} as const;
export type ListDashboardsSearchDomainEnum = (typeof ListDashboardsSearchDomainEnum)[keyof typeof ListDashboardsSearchDomainEnum];
/**
 * @export
 */
export const ListLookupFilesSearchDomainEnum = {
    All: "all",
    Falcon: "falcon",
    ThirdParty: "third-party",
    Dashboards: "dashboards",
    ParsersRepository: "parsers-repository",
} as const;
export type ListLookupFilesSearchDomainEnum = (typeof ListLookupFilesSearchDomainEnum)[keyof typeof ListLookupFilesSearchDomainEnum];
/**
 * @export
 */
export const ListParsersRepositoryEnum = {
    ParsersRepository: "parsers-repository",
} as const;
export type ListParsersRepositoryEnum = (typeof ListParsersRepositoryEnum)[keyof typeof ListParsersRepositoryEnum];
/**
 * @export
 */
export const ListSavedQueriesSearchDomainEnum = {
    All: "all",
    Falcon: "falcon",
    ThirdParty: "third-party",
    Dashboards: "dashboards",
} as const;
export type ListSavedQueriesSearchDomainEnum = (typeof ListSavedQueriesSearchDomainEnum)[keyof typeof ListSavedQueriesSearchDomainEnum];
/**
 * @export
 */
export const UpdateDashboardFromTemplateSearchDomainEnum = {
    All: "all",
    Falcon: "falcon",
    ThirdParty: "third-party",
} as const;
export type UpdateDashboardFromTemplateSearchDomainEnum = (typeof UpdateDashboardFromTemplateSearchDomainEnum)[keyof typeof UpdateDashboardFromTemplateSearchDomainEnum];
/**
 * @export
 */
export const UpdateLookupFileSearchDomainEnum = {
    All: "all",
    Falcon: "falcon",
    ThirdParty: "third-party",
    ParsersRepository: "parsers-repository",
} as const;
export type UpdateLookupFileSearchDomainEnum = (typeof UpdateLookupFileSearchDomainEnum)[keyof typeof UpdateLookupFileSearchDomainEnum];
/**
 * @export
 */
export const UpdateLookupFileEntriesSearchDomainEnum = {
    All: "all",
    Falcon: "falcon",
    ThirdParty: "third-party",
    ParsersRepository: "parsers-repository",
} as const;
export type UpdateLookupFileEntriesSearchDomainEnum = (typeof UpdateLookupFileEntriesSearchDomainEnum)[keyof typeof UpdateLookupFileEntriesSearchDomainEnum];
/**
 * @export
 */
export const UpdateLookupFileEntriesUpdateModeEnum = {
    Append: "append",
    Update: "update",
} as const;
export type UpdateLookupFileEntriesUpdateModeEnum = (typeof UpdateLookupFileEntriesUpdateModeEnum)[keyof typeof UpdateLookupFileEntriesUpdateModeEnum];
/**
 * @export
 */
export const UpdateLookupFileEntriesIgnoreCaseEnum = {
    True: "true",
    False: "false",
} as const;
export type UpdateLookupFileEntriesIgnoreCaseEnum = (typeof UpdateLookupFileEntriesIgnoreCaseEnum)[keyof typeof UpdateLookupFileEntriesIgnoreCaseEnum];
/**
 * @export
 */
export const UpdateParserFromTemplateRepositoryEnum = {
    ParsersRepository: "parsers-repository",
} as const;
export type UpdateParserFromTemplateRepositoryEnum = (typeof UpdateParserFromTemplateRepositoryEnum)[keyof typeof UpdateParserFromTemplateRepositoryEnum];
/**
 * @export
 */
export const UpdateSavedQueryFromTemplateSearchDomainEnum = {
    All: "all",
    Falcon: "falcon",
    ThirdParty: "third-party",
} as const;
export type UpdateSavedQueryFromTemplateSearchDomainEnum = (typeof UpdateSavedQueryFromTemplateSearchDomainEnum)[keyof typeof UpdateSavedQueryFromTemplateSearchDomainEnum];
