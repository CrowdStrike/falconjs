/* tslint:disable */
/* eslint-disable */
/**
 * CrowdStrike API Specification
 * Use this API specification as a reference for the API endpoints you can use to interact with your Falcon environment. These endpoints support authentication via OAuth2 and interact with detections and network containment. For detailed usage guides and more information about API endpoints that don\'t yet support OAuth2, see our [documentation inside the Falcon console](https://falcon.crowdstrike.com/support/documentation). To use the APIs described below, combine the base URL with the path shown for each API endpoint. For commercial cloud customers, your base URL is `https://api.crowdstrike.com`. Each API endpoint requires authorization via an OAuth2 token. Your first API request should retrieve an OAuth2 token using the `oauth2/token` endpoint, such as `https://api.crowdstrike.com/oauth2/token`. For subsequent requests, include the OAuth2 token in an HTTP authorization header. Tokens expire after 30 minutes, after which you should make a new token request to continue making API requests.
 *
 * The version of the OpenAPI document: rolling
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import {
    DomainActorsResponse,
    DomainActorsResponseFromJSON,
    DomainActorsResponseToJSON,
    DomainNewsResponse,
    DomainNewsResponseFromJSON,
    DomainNewsResponseToJSON,
    DomainPublicIndicatorsV3Response,
    DomainPublicIndicatorsV3ResponseFromJSON,
    DomainPublicIndicatorsV3ResponseToJSON,
    DomainRulesResponse,
    DomainRulesResponseFromJSON,
    DomainRulesResponseToJSON,
    MsaErrorsOnly,
    MsaErrorsOnlyFromJSON,
    MsaErrorsOnlyToJSON,
    MsaIdsRequest,
    MsaIdsRequestFromJSON,
    MsaIdsRequestToJSON,
    MsaQueryResponse,
    MsaQueryResponseFromJSON,
    MsaQueryResponseToJSON,
    MsaReplyMetaOnly,
    MsaReplyMetaOnlyFromJSON,
    MsaReplyMetaOnlyToJSON,
} from "../models";

export interface GetIntelActorEntitiesRequest {
    ids: Array<string>;
    fields?: Array<string>;
}

export interface GetIntelIndicatorEntitiesRequest {
    body: MsaIdsRequest;
}

export interface GetIntelReportEntitiesRequest {
    ids: Array<string>;
    fields?: Array<string>;
}

export interface GetIntelReportPDFRequest {
    id: string;
}

export interface GetIntelRuleEntitiesRequest {
    ids: Array<string>;
}

export interface GetIntelRuleFileRequest {
    id: number;
    accept?: string;
    format?: string;
}

export interface GetLatestIntelRuleFileRequest {
    type: string;
    accept?: string;
    format?: string;
    ifModifiedSince?: string;
}

export interface QueryIntelActorEntitiesRequest {
    offset?: number;
    limit?: number;
    sort?: string;
    filter?: string;
    q?: string;
    fields?: Array<string>;
}

export interface QueryIntelActorIdsRequest {
    offset?: number;
    limit?: number;
    sort?: string;
    filter?: string;
    q?: string;
}

export interface QueryIntelIndicatorEntitiesRequest {
    offset?: number;
    limit?: number;
    sort?: string;
    filter?: string;
    q?: string;
    includeDeleted?: boolean;
    includeRelations?: boolean;
}

export interface QueryIntelIndicatorIdsRequest {
    offset?: number;
    limit?: number;
    sort?: string;
    filter?: string;
    q?: string;
    includeDeleted?: boolean;
    includeRelations?: boolean;
}

export interface QueryIntelReportEntitiesRequest {
    offset?: number;
    limit?: number;
    sort?: string;
    filter?: string;
    q?: string;
    fields?: Array<string>;
}

export interface QueryIntelReportIdsRequest {
    offset?: number;
    limit?: number;
    sort?: string;
    filter?: string;
    q?: string;
}

export interface QueryIntelRuleIdsRequest {
    type: string;
    offset?: number;
    limit?: number;
    sort?: string;
    name?: Array<string>;
    description?: Array<string>;
    tags?: Array<string>;
    minCreatedDate?: number;
    maxCreatedDate?: string;
    q?: string;
}

/**
 *
 */
export class IntelApi extends runtime.BaseAPI {
    /**
     * Retrieve specific actors using their actor IDs.
     */
    async getIntelActorEntitiesRaw(requestParameters: GetIntelActorEntitiesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<DomainActorsResponse>> {
        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError("ids", "Required parameter requestParameters.ids was null or undefined when calling getIntelActorEntities.");
        }

        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters["ids"] = requestParameters.ids;
        }

        if (requestParameters.fields) {
            queryParameters["fields"] = requestParameters.fields;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falconx-actors:read"]);
        }

        const response = await this.request(
            {
                path: `/intel/entities/actors/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainActorsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve specific actors using their actor IDs.
     */
    async getIntelActorEntities(ids: Array<string>, fields?: Array<string>, initOverrides?: RequestInit): Promise<DomainActorsResponse> {
        const response = await this.getIntelActorEntitiesRaw({ ids: ids, fields: fields }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve specific indicators using their indicator IDs.
     */
    async getIntelIndicatorEntitiesRaw(requestParameters: GetIntelIndicatorEntitiesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<DomainPublicIndicatorsV3Response>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError("body", "Required parameter requestParameters.body was null or undefined when calling getIntelIndicatorEntities.");
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falconx-indicators:read"]);
        }

        const response = await this.request(
            {
                path: `/intel/entities/indicators/GET/v1`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: MsaIdsRequestToJSON(requestParameters.body),
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainPublicIndicatorsV3ResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve specific indicators using their indicator IDs.
     */
    async getIntelIndicatorEntities(body: MsaIdsRequest, initOverrides?: RequestInit): Promise<DomainPublicIndicatorsV3Response> {
        const response = await this.getIntelIndicatorEntitiesRaw({ body: body }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve specific reports using their report IDs.
     */
    async getIntelReportEntitiesRaw(requestParameters: GetIntelReportEntitiesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<DomainNewsResponse>> {
        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError("ids", "Required parameter requestParameters.ids was null or undefined when calling getIntelReportEntities.");
        }

        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters["ids"] = requestParameters.ids;
        }

        if (requestParameters.fields) {
            queryParameters["fields"] = requestParameters.fields;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falconx-reports:read"]);
        }

        const response = await this.request(
            {
                path: `/intel/entities/reports/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainNewsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve specific reports using their report IDs.
     */
    async getIntelReportEntities(ids: Array<string>, fields?: Array<string>, initOverrides?: RequestInit): Promise<DomainNewsResponse> {
        const response = await this.getIntelReportEntitiesRaw({ ids: ids, fields: fields }, initOverrides);
        return await response.value();
    }

    /**
     * Return a Report PDF attachment
     */
    async getIntelReportPDFRaw(requestParameters: GetIntelReportPDFRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling getIntelReportPDF.");
        }

        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters["id"] = requestParameters.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falconx-reports:read"]);
        }

        const response = await this.request(
            {
                path: `/intel/entities/report-files/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Return a Report PDF attachment
     */
    async getIntelReportPDF(id: string, initOverrides?: RequestInit): Promise<Blob> {
        const response = await this.getIntelReportPDFRaw({ id: id }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve details for rule sets for the specified ids.
     */
    async getIntelRuleEntitiesRaw(requestParameters: GetIntelRuleEntitiesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<DomainRulesResponse>> {
        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError("ids", "Required parameter requestParameters.ids was null or undefined when calling getIntelRuleEntities.");
        }

        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters["ids"] = requestParameters.ids;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falconx-rules:read"]);
        }

        const response = await this.request(
            {
                path: `/intel/entities/rules/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainRulesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve details for rule sets for the specified ids.
     */
    async getIntelRuleEntities(ids: Array<string>, initOverrides?: RequestInit): Promise<DomainRulesResponse> {
        const response = await this.getIntelRuleEntitiesRaw({ ids: ids }, initOverrides);
        return await response.value();
    }

    /**
     * Download earlier rule sets.
     */
    async getIntelRuleFileRaw(requestParameters: GetIntelRuleFileRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling getIntelRuleFile.");
        }

        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters["id"] = requestParameters.id;
        }

        if (requestParameters.format !== undefined) {
            queryParameters["format"] = requestParameters.format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters["Accept"] = String(requestParameters.accept);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falconx-rules:read"]);
        }

        const response = await this.request(
            {
                path: `/intel/entities/rules-files/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Download earlier rule sets.
     */
    async getIntelRuleFile(id: number, accept?: string, format?: string, initOverrides?: RequestInit): Promise<Blob> {
        const response = await this.getIntelRuleFileRaw({ id: id, accept: accept, format: format }, initOverrides);
        return await response.value();
    }

    /**
     * Download the latest rule set.
     */
    async getLatestIntelRuleFileRaw(requestParameters: GetLatestIntelRuleFileRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError("type", "Required parameter requestParameters.type was null or undefined when calling getLatestIntelRuleFile.");
        }

        const queryParameters: any = {};

        if (requestParameters.type !== undefined) {
            queryParameters["type"] = requestParameters.type;
        }

        if (requestParameters.format !== undefined) {
            queryParameters["format"] = requestParameters.format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters["Accept"] = String(requestParameters.accept);
        }

        if (requestParameters.ifModifiedSince !== undefined && requestParameters.ifModifiedSince !== null) {
            headerParameters["If-Modified-Since"] = String(requestParameters.ifModifiedSince);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falconx-rules:read"]);
        }

        const response = await this.request(
            {
                path: `/intel/entities/rules-latest-files/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Download the latest rule set.
     */
    async getLatestIntelRuleFile(type: string, accept?: string, format?: string, ifModifiedSince?: string, initOverrides?: RequestInit): Promise<Blob> {
        const response = await this.getLatestIntelRuleFileRaw({ type: type, accept: accept, format: format, ifModifiedSince: ifModifiedSince }, initOverrides);
        return await response.value();
    }

    /**
     * Get info about actors that match provided FQL filters.
     */
    async queryIntelActorEntitiesRaw(requestParameters: QueryIntelActorEntitiesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<DomainActorsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.q !== undefined) {
            queryParameters["q"] = requestParameters.q;
        }

        if (requestParameters.fields) {
            queryParameters["fields"] = requestParameters.fields;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falconx-actors:read"]);
        }

        const response = await this.request(
            {
                path: `/intel/combined/actors/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainActorsResponseFromJSON(jsonValue));
    }

    /**
     * Get info about actors that match provided FQL filters.
     */
    async queryIntelActorEntities(offset?: number, limit?: number, sort?: string, filter?: string, q?: string, fields?: Array<string>, initOverrides?: RequestInit): Promise<DomainActorsResponse> {
        const response = await this.queryIntelActorEntitiesRaw({ offset: offset, limit: limit, sort: sort, filter: filter, q: q, fields: fields }, initOverrides);
        return await response.value();
    }

    /**
     * Get actor IDs that match provided FQL filters.
     */
    async queryIntelActorIdsRaw(requestParameters: QueryIntelActorIdsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<MsaQueryResponse>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.q !== undefined) {
            queryParameters["q"] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falconx-actors:read"]);
        }

        const response = await this.request(
            {
                path: `/intel/queries/actors/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaQueryResponseFromJSON(jsonValue));
    }

    /**
     * Get actor IDs that match provided FQL filters.
     */
    async queryIntelActorIds(offset?: number, limit?: number, sort?: string, filter?: string, q?: string, initOverrides?: RequestInit): Promise<MsaQueryResponse> {
        const response = await this.queryIntelActorIdsRaw({ offset: offset, limit: limit, sort: sort, filter: filter, q: q }, initOverrides);
        return await response.value();
    }

    /**
     * Get info about indicators that match provided FQL filters.
     */
    async queryIntelIndicatorEntitiesRaw(requestParameters: QueryIntelIndicatorEntitiesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<DomainPublicIndicatorsV3Response>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.q !== undefined) {
            queryParameters["q"] = requestParameters.q;
        }

        if (requestParameters.includeDeleted !== undefined) {
            queryParameters["include_deleted"] = requestParameters.includeDeleted;
        }

        if (requestParameters.includeRelations !== undefined) {
            queryParameters["include_relations"] = requestParameters.includeRelations;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falconx-indicators:read"]);
        }

        const response = await this.request(
            {
                path: `/intel/combined/indicators/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainPublicIndicatorsV3ResponseFromJSON(jsonValue));
    }

    /**
     * Get info about indicators that match provided FQL filters.
     */
    async queryIntelIndicatorEntities(
        offset?: number,
        limit?: number,
        sort?: string,
        filter?: string,
        q?: string,
        includeDeleted?: boolean,
        includeRelations?: boolean,
        initOverrides?: RequestInit
    ): Promise<DomainPublicIndicatorsV3Response> {
        const response = await this.queryIntelIndicatorEntitiesRaw(
            { offset: offset, limit: limit, sort: sort, filter: filter, q: q, includeDeleted: includeDeleted, includeRelations: includeRelations },
            initOverrides
        );
        return await response.value();
    }

    /**
     * Get indicators IDs that match provided FQL filters.
     */
    async queryIntelIndicatorIdsRaw(requestParameters: QueryIntelIndicatorIdsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<MsaQueryResponse>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.q !== undefined) {
            queryParameters["q"] = requestParameters.q;
        }

        if (requestParameters.includeDeleted !== undefined) {
            queryParameters["include_deleted"] = requestParameters.includeDeleted;
        }

        if (requestParameters.includeRelations !== undefined) {
            queryParameters["include_relations"] = requestParameters.includeRelations;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falconx-indicators:read"]);
        }

        const response = await this.request(
            {
                path: `/intel/queries/indicators/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaQueryResponseFromJSON(jsonValue));
    }

    /**
     * Get indicators IDs that match provided FQL filters.
     */
    async queryIntelIndicatorIds(
        offset?: number,
        limit?: number,
        sort?: string,
        filter?: string,
        q?: string,
        includeDeleted?: boolean,
        includeRelations?: boolean,
        initOverrides?: RequestInit
    ): Promise<MsaQueryResponse> {
        const response = await this.queryIntelIndicatorIdsRaw(
            { offset: offset, limit: limit, sort: sort, filter: filter, q: q, includeDeleted: includeDeleted, includeRelations: includeRelations },
            initOverrides
        );
        return await response.value();
    }

    /**
     * Get info about reports that match provided FQL filters.
     */
    async queryIntelReportEntitiesRaw(requestParameters: QueryIntelReportEntitiesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<DomainNewsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.q !== undefined) {
            queryParameters["q"] = requestParameters.q;
        }

        if (requestParameters.fields) {
            queryParameters["fields"] = requestParameters.fields;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falconx-reports:read"]);
        }

        const response = await this.request(
            {
                path: `/intel/combined/reports/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainNewsResponseFromJSON(jsonValue));
    }

    /**
     * Get info about reports that match provided FQL filters.
     */
    async queryIntelReportEntities(offset?: number, limit?: number, sort?: string, filter?: string, q?: string, fields?: Array<string>, initOverrides?: RequestInit): Promise<DomainNewsResponse> {
        const response = await this.queryIntelReportEntitiesRaw({ offset: offset, limit: limit, sort: sort, filter: filter, q: q, fields: fields }, initOverrides);
        return await response.value();
    }

    /**
     * Get report IDs that match provided FQL filters.
     */
    async queryIntelReportIdsRaw(requestParameters: QueryIntelReportIdsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<MsaQueryResponse>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters["filter"] = requestParameters.filter;
        }

        if (requestParameters.q !== undefined) {
            queryParameters["q"] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falconx-reports:read"]);
        }

        const response = await this.request(
            {
                path: `/intel/queries/reports/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaQueryResponseFromJSON(jsonValue));
    }

    /**
     * Get report IDs that match provided FQL filters.
     */
    async queryIntelReportIds(offset?: number, limit?: number, sort?: string, filter?: string, q?: string, initOverrides?: RequestInit): Promise<MsaQueryResponse> {
        const response = await this.queryIntelReportIdsRaw({ offset: offset, limit: limit, sort: sort, filter: filter, q: q }, initOverrides);
        return await response.value();
    }

    /**
     * Search for rule IDs that match provided filter criteria.
     */
    async queryIntelRuleIdsRaw(requestParameters: QueryIntelRuleIdsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<MsaQueryResponse>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError("type", "Required parameter requestParameters.type was null or undefined when calling queryIntelRuleIds.");
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters["offset"] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters["limit"] = requestParameters.limit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters["sort"] = requestParameters.sort;
        }

        if (requestParameters.name) {
            queryParameters["name"] = requestParameters.name.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.type !== undefined) {
            queryParameters["type"] = requestParameters.type;
        }

        if (requestParameters.description) {
            queryParameters["description"] = requestParameters.description.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tags) {
            queryParameters["tags"] = requestParameters.tags.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.minCreatedDate !== undefined) {
            queryParameters["min_created_date"] = requestParameters.minCreatedDate;
        }

        if (requestParameters.maxCreatedDate !== undefined) {
            queryParameters["max_created_date"] = requestParameters.maxCreatedDate;
        }

        if (requestParameters.q !== undefined) {
            queryParameters["q"] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["falconx-rules:read"]);
        }

        const response = await this.request(
            {
                path: `/intel/queries/rules/v1`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MsaQueryResponseFromJSON(jsonValue));
    }

    /**
     * Search for rule IDs that match provided filter criteria.
     */
    async queryIntelRuleIds(
        type: string,
        offset?: number,
        limit?: number,
        sort?: string,
        name?: Array<string>,
        description?: Array<string>,
        tags?: Array<string>,
        minCreatedDate?: number,
        maxCreatedDate?: string,
        q?: string,
        initOverrides?: RequestInit
    ): Promise<MsaQueryResponse> {
        const response = await this.queryIntelRuleIdsRaw(
            { type: type, offset: offset, limit: limit, sort: sort, name: name, description: description, tags: tags, minCreatedDate: minCreatedDate, maxCreatedDate: maxCreatedDate, q: q },
            initOverrides
        );
        return await response.value();
    }
}
